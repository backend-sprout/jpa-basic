트랜잭션과 락, 2차캐시
=======================
# 트랜잭션과 격리 수준 

**트랜잭션은 ACID라 하는 원자성, 일광성, 격리성, 지속성을 보장해야한다.**   

* **원시성(Atomicity) :** 트랜잭션 내에서 실행한 작업들은 마치 하나의 작업인 것처럼 모두 성공하거나 모두 실패해야 한다.    
* **일관성(Consistency) :** 모든 트랜잭션은 일관성 있는 데이터베이스 상태를 유지해야한다.      
  예를 들어 데이터베이스에서 정한 무결성 제약 조약 조건을 항상 만족해야한다.     
* **격리성(Isolation) :** 동시에 실행되는 트랜잭션들이 서로에게 영향을 미치지 않도록 격리한다.     
  예를 들어 동시에 같은 데이터를 수정하지 못하도록 해야 한다.       
  격리성은 동시성과 관련된 성능 이슈로 인해 격리 수준을 선택할 수 있다.       
* **지속성(Durabillity) :** 트랜잭션을 성공적으로 끝내면 그 결과가 항상 기록되어야 한다.    
  중간에 시스템에 문제가 발생해도 데이터베이스 로그 등을 사용해서 성공한 트랜잭션 내용을 복구해야한다.     
   
ACID 특징 중 문제는 격리성이다.    
트랜잭션간에 격리성을 완벽히 보장하려면 트랜잭션을 거의 차례대로 실행해야한다.     
다만, 이 같은 방식을 취하면 동시성 처리 성능 속도가 매우 나빠진다.      
 
이 같은 문제를 해결하고자 ANSI 표준은 트랜잭션의 격리 수준을 4단계로 나누어 정의했다.    

**트랜잭션 격리 수준**
* READ UNCOMMITED : 커밋되지 않은 읽기      
* READ COMMITTED : 커밋된 읽기 
* REPEATABLE READ : 반복 가능한 읽기 
* SERIALIZABLE : 직렬화 가능  

위부터 아래 순서대로 `READ UNCOMMITED`의 격리 수준이 낮고 `SERIALIZABLE`의 격리 수준이 가장 높다.   
격리 수준이 낮을수록 동시성은 증가하지만 다양한 문제가 발생할 가능성이 높다.    

|격리 수준|DIRTY READ|NON-REPEATABLE READ|PHANTOM READ|  
|--------|----------|--------------------|------------|     
|UNCOMMITED|O|O|O|  
|READ COMMITTED||O|O|  
|REPEATABLE READ|||O|  
|SERIALIZABLE||||  
  
격리 수준에 따른 문제점은 아래와 같다.   

* DIRTY READ   
* NON-REPEATBLE READ(반복 가능한 읽기)    
* PHANTOM READ   

## READ UNCOMMITTED(커밋 되기전에도 읽을 수 있음) 
커밋하지 않은 데이터를 읽을 수 있다.   

```
트랜잭션1이 데이터를 수정하고 있고 커밋하지 않은 상태      
트랜잭션2가 수정중인 데이터를 조회할 수 있다.         
```
이러한 동작을 DIRTY READ라고 부르고    
이를 허용하는 것이 바로 READ UNCOMMITTED 이다.     
            
하지만, 트랜잭션2가 DIRTY READ한 데이터를 사용하는데        
트랜잭션1을 롤백하면 데이터 정합성에 심각한 문제가 발생할 수 있다.       

대부분의 데이터베이스는 격리수준 LV1 인, READ COMMITTED 를 지원하기에 DIRTY READ는 발생하는 경우는 적다.   
       
## READ COMMITTED    
커밋한 데이터만 읽을 수 있다.        
**DIRTY READ가 발생하지 않지만, NON-REPEATABLE READ는 발생할수 있다.**         

```
트랜잭션1이 회원A를 조회중이다.     
트랜잭션2가 회원A를 수정하고 커밋한다.     
트랜잭션1이 다시 회원 A를 조회했을 때 수정된 데이터가 조회된다.    

// 조회값이 달라서 계속 반복해서 읽는지  
// 아니면 데이터가 달라진 상태로 조회되서 원하는 로직이 꼬이는게 문젠지.. 후자일 것 같은데 찾아보자 
```
이처럼 반복해서 같은 데이터를 읽을 수 없는 상태를 `NON-REPEATABLE READ`이라고 부른다.      
즉, 두 쿼리의 결과가 상이하게 나타나는 비일관성이 발생하는 것을 말한다.           
DIRTY READ는 지원하지 않지만, NON-REPEATABLE READ는 허용하는 격리수준이 READ COMMITTED이다.    
     
## REPEATABLE READ     
한번 조회한 데이터를 반복해서 조회해도 같은 데이터가 조회된다.           
즉, NON-REPEATABLE READ는 발생하지 않지만 대신에 PHANTOM READ는 발생할 수 있다.     

```
트랜잭션1이 10살 이하의 회원을 조회했다.   
트랜잭션2가 5살 회원을 추가하고 커밋한다.    
트랜잭션1이 다시 10살 이하의 회원을 조회했을 때 회원 하나가 추가된 상태로 조회된다.   
```
이처럼 반복 조회시 결과 집합이 달라지는 것을 PHANTOM READ라 한다.      
NON-REPEATABLE READ는 허용하지 않지만 PHANTOM READ는 허용하는 격리수준이 REPEATABLE READ이다.  

## SERIALIZABLE    
가장 엄격한 트랜잭션 격리 수준이다.     
PHANTOM READ가 발생하지 않지만 동시성 처리 성능이 급격하게 떨어질 수 있다.     
   
애플리케이션 대부분은 동시성 처리가 중요하므로 DB들은 READ COMMITTED 격리 수준을 기본으로 사용한다.        
일부 중요한 비즈니스 로직에 더 높은 격리 수준이 필요하면 DB 트랜잭션이 제공하는 잠금 기능을 사용하면 된다.     

# 낙관적 락과 비관적 락 기초   
JPA의 영속성 컨텍스트를 적절히 활용하면         
**DB 트랜잭션이 READ COMMITTED 격리 수준이어도 애플리케이션 레벨에서 REPEATED READ가 가능하다.**            
물론, 엔티티가 아닌 스칼라 값을 직접 조회하면 영속성 컨텍스트의 관리를 받지 못하므로 REPEATABLE READ 를 할 수 없다.   
   
JPA는 DB 트랜잭션 격리 수준을 READ COMMITTED 로 가정한다.     
만약 일부 로직에 더 높은 격리 수준이 필요하면 낙관적 락과 비관적 락 중 하나를 사용하면된다.     
      
**낙관적 락**은 이름 그대로 **트랜잭션 대부분은 충돌이 발생하지 않는다고 낙관적으로 가정하는 방법이다.**   
DB가 제공해주는 `락` 기능을 사용하는 것이 아니라           
**JPA가 제공해주는 `버전 관리` 기능을 사용한다.(애플리케이션에서 제공하는 락)**          
낙관적 락은 **트랜잭션을 커밋하기 전까지는 트랜잭션의 충돌을 알 수 없다는 특징이 있다.**       
  
**비관적 락**은 이름 그대로 **트랜잭션의 충돌이 발생한다고 가정하고 우선 락을 걸고 보는 방법이다.**          
DB가 제공하는 락 기능을 사용하는데 이때, 대표적으로 select for update 구문이 있다.([참고](https://dololak.tistory.com/446))  
**`select for update`는 쉽게 말하면 데이터 변경을 위해 SELECT 중이니 다른 트랜잭션은 건드리지마!** 를 뜻하며  
이론적으로 표현하자면 동시성 제어를 위하여 특정 데이터(ROW)에 대해 베타적 LOCK을 거는 기능이다.     
















