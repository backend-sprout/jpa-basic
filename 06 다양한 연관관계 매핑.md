# 06 다양한 연관관계 매핑    
엔티티의 연관관계를 매핑할 때는 다음 3가지 고려사항이 있다.           
       
* **다중성**       
* **단방향, 양방향**                       
* **연관관계의 주인**
    
## 다중성    
* 다대일: `@ManyToOne`  
* 일대다: `@OneToMany`   
* 일대일: `@OneToOne`    
* 다대다: `@ManyToMany`   
  
다중성을 판단하기 어려울 때는 반대방향을 생각하면 된다.     

* 일대다 -> 다대일
* 일대일 -> 일대일
    
보통 `다대일`을 많이 사용하고      
`다대다` 관계는 실무에서 거의 사용하지 않는다.     
      
## 단방향, 양방향  
DB 테이블은 `방향`이라는 개념이 없다.      
반면에 객체는 `참조`가 있어야만 해당 객체를 탐색하므로 `방향`이 있다.   
   
* 객체 관계에서 `다른 객체를 참조`하고 있다면 단방향이다.  
* 객체 관계에서 `서로간에 참조`하고 있다면 양방향이다. 
   
## 연관관계의 주인    
연관관계의 주인이란, DB 테이블을 기준으로 외래키를 관리하는 테이블을 매핑한 객체를 뜻한다.       
연관관계의 주인은 DB의 데이터를 실질적으로 처리한다.`(CRUD)`   
반면에 주인이 아닌 객체는 `READ`만 가능하다.      
    
* 연관된 객체를 주인으로 인정하기 위해 `mappedBy=`를 사용한다.        
     
# 다대일(N:1)       
다대일 관계의 반대 방향은 항상 일대다 관계고       
일대다 관계의 반대 방향은 항상 다대일 관계이다.          
     
DB 에서 외래 키는 항상 `다`에 있다.     
따라서 객체 양방향 관계에서 연관관계의 주인은 항상 `다`쪽이다.     
    
## 다대일 단방향 
`다대일 단방향`은 가장 많이 사용하는 연관관계이며   
우리가 추구해야할 `연관관계`이다.    

**Member**
```java
@Entity
public class Member {
    
    @Id @GeneratedValue
    @Column(name = "MEMBER_ID")
    private Long id;
    
    private String username;
    
    @ManyToOne
    @Joincolumn(name = "TEAM_ID")
    private Team team;
    
    // Getter, Setter
    ...
}
```  
**Team**
```java
@Entity
public class Team {
    
    @Id @GeneratedValue
    @Column(name = "TEAM_ID")
    private Long id;
    
    private String name;
   
    // Getter, Setter
    ...
}
```
회원은 `Member.team`을 통해서 `Team 엔티티`를 조회할 수 있다.       
반대로 팀은 회원을 참조하는 필드가 없기에 `다대일 단방향` 연관관계가 되었다.         
     
`Member`는 `@Joincolumn`을 통해,       
`TEAM_ID`라는 외래키를 관리하며, 의존관계 주인이 되어 DB로직 처리를 담당한다.   

## 다대일 양방향 
양방향이기에 두 객체 중 하나의 객체를 연관관계의 주인으로 지정해야한다.   
대개, 외래키가 있는 쪽이 연관관계의 주인이 된다.  

**Member**
```java
@Entity
public class Member {
    
    @Id @GeneratedValue
    @Column(name = "MEMBER_ID")
    private Long id;
    
    private String username;
    
    @ManyToOne
    @Joincolumn(name = "TEAM_ID")
    private Team team;
    
    public void setTeam(Team team) {
        this.team = team;
        
        // 무한루프에 빠지지 않도록 체크 
        if(!team.getMembers().contains(this)) {
            team.getMembers().add(this);
        }
    }
}
```  
**Team**
```java
@Entity
public class Team {
    
    @Id @GeneratedValue
    @Column(name = "TEAM_ID")
    private Long id;
    
    private String name;
   
    @OneToMany(mappedBy = "team")
    private List<Member> members = new ArrayList<>();
    
    public void addMember(Member member) {
        this.members.add(member);
        if (member.getTeam() != this) {  // 무한루프에 빠지지 않도록 체크 
            member.setTeam(this);
        }
    }
}
```


# 일대다(1:N)     
## 일대다 단방향   
일대다 단방향은 다대일 단방향과는 반대로      
`일`쪽이 연관관걔의 주인이 되고   
`다`쪽이 데이터를 읽기만 하는 엔티티가 된다.    
     
그러나 `DB 테이블`을 다시 한번 생각해보면 외래키는 항상 `다` 쪽에 존재했다.    
       
이러한 `객체`와 `테이블`의 차이 때문에,       
반대편 테이블의 외래 키를 관리하는 형태가 된 것을 알 수 있다.         
            
실제로 실행된 `SQL 문`을 보게 된다면    
`UPDATE 문`이 실행되는 것을 알 수 있다.    
     
## 일대다 양방향   
이런 매핑은 공식적으로 지원하지 않는 매핑이다.      
    
```java
@JoinColumn(insertable=false, updatable=false)
private 엔티티 참조변수; 
```            
   
그렇기 때문에 위와 같이 읽기 전용 필드를 사용해서         
양방향처럼 사용하는 방법을 이용할 수 있다.                
          
하지만, 이런 매핑은 권장하지 않기에 차라리 다대일 양방향을 사용하자        

      
# 일대일(1:1)          
일대일 관계는 그 반대도도 일대일이라는 특징을 가지고 있다.            
그렇기에, 주 테이블이나 대상 테이블 상관 없이, 아무 테이블에서나 외래키를 관리 가능하다.          
또한, 1대1 관계이기에 `unique` 제약 조건을 사용할 수 있다.(권장한다)           
   
**주 테이블에 외래키**  
주 객체가 대상 객체를 참조하는 것처럼, 주 테이블에 외래 키를 두고 대상 테이블을 참조한다.    
외래키를 객체 참조와 비슷하게 사용할 수 있어서 객체지향 개발자들이 선호한다.   
또한, `주 테이블이 자주 조회되는 객체라면 객체 탐색 그래프를 이용하기 편해진다.`    
   
**대상 테이블에 외래키**   
전통적인 DBA 분들은 대상 테이블에 외래키를 두는 것을 선호한다.   
이 방법의 장점은 `일대일에서 일대다로 변환이 필요할 때`, 구조를 변경할 필요가 없다는 점이다.  

# 다대다(N:M)   
RDB 는 정규화된 테이블 2개로 다대다 관계를 표현할 수 없다.      
그렇기에, 다대다 관계를 `일대다 + 다대일` 관계로 풀어내는 **연결 테이블**을 사용한다.       
   
그러나 객체는 테이블과 다르게 **객체 2개만 가지고서도 다대다 관계를 만들 수 있다.**   
서로간에 객체를 컬렉션을 이용하여 저장하고 참조하면 되기 때문이다.  

## 다대다 단방향
  
**Member**
```java
@Entitiy
public class Member {
    
    @Id @Column(name = "MEMBER_ID")
    private String id;
    
    private String username;
    
    @ManyToMany
    @JoinTable(name = "MEMBER_PRODUCT", 
               joinColumns = @JoinColumn(name = "MEMBER_ID"),
               inverseJoinColumns = @JoinColumn(name = "PRODUCT_ID"),
    private LIst<Product> products = new ArrayList<Product>();           
}
```

**Product**
```java
@Entity
public class Product {
    
    @Id @Column(name = "PRODUCT_ID") 
    private string id;
    
    private String name;
    ...
}
```
* `@JoinTable(name = "이름")` : 연결 테이블을 생성하고, 이름을 지정한다.   
* `joinColumns = @JoinColumn(name = "이름")` : 현재 방향인 Member와 매핑할 조인 컬럼 정보를 지정한다.
* `inverseJoinColumns = @JoinColumn(name = "이름")`: 반대 방향인 상품과 매핑할 조인 컬럼 정보를 지정한다.   
  
|속성|기능|  
|---|----|    
|joinColumns|현재 엔티티를 참조하는 `연결 테이블간의 외래키`|    
|inverseJoinColumns|반대방향 엔티티를 참조하는 `연결 테이블간의 외래키`|    
  
`@ManyToMany`를 통해 다대다 관계를 설정할 경우   
DB 테이블의 `연결 테이블`과 같은 개념을 신경쓰지 않고도 구현할 수 있다.    
  
이와 같이 정의할 경우   
우리는 참조한 객체를 탐색해서 사용하는 것 같지만,    
DB 테이블 관점에서 보면 `연결 테이블`에서 데이터를 가져오고 있다.   

## 다대다 양방향 
기존 `Product` 클래스의 코드에서 `mappedBy` 를 추가하면 된다. 
**Product**
```java
@Entity
public class Product {
    
    @Id @Column(name = "PRODUCT_ID") 
    private string id;
    
    private String name;
      
    @ManyToMany(mappedBy = "products")   
    List<Member> members = new ArrayList<>();
    ...
}
```
## 다대다 매핑의 한계와 극복, 연결 엔티티 사용  
보통 연결 테이블에는 기존의 테이블들의 정보 말고도 추가 정보고 필요하다.     
`주문`을 가정했을시, `수량 컬럼/주문한 날짜`같은 정보들 말이다.         
   
이러한 경우 `객체 연결관계`에서는 새로운 컬럼들을 매핑할 수 없다는 문제가 발생한다.       
그러므로 이를 처리하기 위해서 `연결 테이블`과 대비되는 `연결 엔티티`를 만드는 것이 좋다.     
  
```java
@Enitity
@IdClass(MemberProductId.class)   
public class MemberProduct {
    
    @Id
    @ManyToOne
    @JoinColumn(name = "MEMBER_ID")
    private Member member;
    
    @Id
    @ManyToOne
    @JoinColumn(name = "PRODUCT_ID")
    private Product product;
    
    // 추가될 컬럼 
    private int orderAmount;
}
```


```java
@Enitity
@IdClass(MemberProductId.class)   
public class MemberProduct {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne
    @JoinColumn(name = "MEMBER_ID")
    private Member member;
    
    @ManyToOne
    @JoinColumn(name = "PRODUCT_ID")
    private Product product;
    
    // 추가될 컬럼 
    private int orderAmount;
}
```
