# 엔티티 매핑  
JPA를 사용함에 있어 가장 중요한 일은 **엔티티**와 **테이블**을 매핑하는 과정이다.     
따라서 JPA를 올바르게 활용하고자 한다면, 매핑 어노테이션을 숙지하고 사용해야 한다.       
   
* 객체와 테이블 : `@Entity`, `@Table`  
* 기본 키 매핑 : `@Id`
* 필드와 컬럼 매핑 : `@Column`  
* 연관관계 매핑 : `@ManyToOne`, `@JoinColumn`   

# @Entity
`@Entity`붙은 클래스는 JPA가 관리하는 클래스로 지정하는 것으로   
JPA를 사용해서 테이블과 매핑할 클래스는 `@Entity` 어노테이션을 필수로 붙여야한다.   
그리고 이러한 클래스를 우리는 `엔티티`라고 부른다.  

|속성|기능|기본값|
|----|----|------|
|name|JPA에서 사용할 엔티티 이름을 지정한다.<br>보통 기본값인 클래스 이름을 사용하지만,<br>다른 디렉토리에 동일한 이름의 클래스가 있다면 충돌이 난다.<br>이 같은 경우는 해당 속성 값을 통해 이름을 변경해주자|클래스의 이름을 그대로 사용한다.|     

**`@Entity` 주의사항**   
* 기본 생성자는 필수다.(파라미터가 없는 / public, protected 로만 가능)  
* `final 클래스`, `enum`, `interface`, `inner 클래스`에는 사용할 수 없다.   
* 저장할 필드에 `final`을 사용하면 안 된다.    
  
이러한 주의사항 때문에 `디폴트 생성자`를 고려해볼 수는 있지만,      
아시다시피 다른 생성자가 존재하면 자동으로 추가되지 않으므로     
`기본 생성자`는 명확히 기술해주도록 하는 것이 좋다.     
    
**궁금증, 정말로 final을 사용할 수는 없는 것일까? 🤔**   
* 사실, 엔티티 클래스에도 `final`을 사용할 수 있으며 기본적인 동작에는 문제가 없다. 
* 단, JPA는 지연로딩(lazy-loading)시에 proxy 객체를 만드는데 이때 사용이 불가능해진다.   
    * 지연로딩은 `proxy 객체`를 만들어 놓았다가 실제 엔티티를 사용할 때 쿼리를 날려서 값을 가져온다.      
    * 그렇기에 이러한 `proxy 객체`에서 문제가 발생하기에 사용하지 말라고 권장하는 것이다.
* 참고로 `final`을 사용할 경우 코틀린에서는 문제가 크게 발생한다고 한다.        
* [참고 사이트](https://effectivesquid.tistory.com/entry/Kotlin-JPA-%EC%82%AC%EC%9A%A9%EC%8B%9C-Entity-%EC%A0%95%EC%9D%98)

# @Table  
`@Table`은 엔티티와 매핑할 테이블을 지정한다.   
    
|속성|기능|기본값|
|----|----|------|
|name|매핑할 테이블 이름|엔티티 이름을 사용한다.|
|[catalog](https://stackoverflow.com/questions/11184025/what-are-the-jpa-table-annotation-catalog-and-schema-variables-used-for)|catalog  기능이 있는 데이터베이스에서 catalog를 매핑한다.||
|schema|schema 기능이 있는 데이터베이스에서 schema를 매핑한다.<br>참고로 이전에, `스키마 == 데이터베이스`라는 식으로 인식이 되었는데<br>해당 부분에 대해서 명확히 나눠야 하므로 [참고사이트](https://ko.strephonsays.com/schema-and-vs-table-9593)를 기록한다.||
|uniqueConstraints(DDL)|DDL 생성시에 유니크 제약조건을 만든다.<br>2개 이상의 복합 유니크 제약 조건도 만들 수 있다.<br>참고로 스키마 자동 생성 기능을 사용해서 DDL을 만들때만 사용된다.|   
  
**Entity 와 Table 동시에 name을 설정한다면? 🤔**     
```java
@Entity(name = "someThing") // this name will be used to name the Entity
@Table(name = "someThing")  // this name will be used to name a table in DB
// `@Entity`는 엔티티의 이름 및 식별을 위해 사용된다.  
// `@Table`은 테이블을 매핑하기 위해  이름 및 식별을 위해 사용된다.  
```
* `@Entity`는 [HQL](https://docs.jboss.org/hibernate/orm/3.3/reference/ko-KR/html/queryhql.html)에서 엔티티를 식별할 이름을 정한다.  
* `@Table`은 실제 매핑할 `Database`에 생성될 `table`의 이름을 지정할때 사용된다.  
* `@Entity(name ="")`만 존재하는 경우, `@Entity`의 `name` 속성에 의해, `Entity`와 `Table` 이름이 모두 결정된다.    
* [인프런 질문](https://www.inflearn.com/questions/75556)   
* [스택 오버플로우](https://stackoverflow.com/questions/18732646/name-attribute-in-entity-and-table)   
* [참고사이트](https://walkingtechie.blogspot.com/2019/06/difference-between-entity-and-table.html)   

# @Id 
`@Id`는 기본키 매핑에 사용되는 어노테이션이다.   
그렇다면, DB가 제공하는 기본키 전략을 적용하려면 어떻게 해야할까?   
   
`JPA`가 제공하는 `DB` 기본키 생성 전략은 다음과 같다.    
* **직접 할당:** 기본키를 애플리케이션에서 직접 할당
* **자동 생성:** 대리키 사용 방식
    * `@GenerateValue` 어노테이션을 사용한다. 
    * **IDENTITY :** 기본 키 생성을 DB에 위임한다.
    * **SEQUENCE :** DB 시퀀스를 사용해서 기본키를 할당한다.
    * **TABLE :** 키 생성 테이블을 이용한다.     
    * **자동 생성 전략이 다양한 이유는?** -> DB 벤더마다 지원 방식이 다르기 때문이다.    
        * SEQUENCE : Oracle   
        * IDENTITY(AUTO_INCREAMENT) : MySQL 
        * TABLE : 키 생성용 테이블 만들어서 사용하는 전략  
         
```
사실, 키 생성 전략을 사용하려면 persistence.xml에  
hibernate.id.new_generator_mappings=true 속성을 반드시 추가해야한다.   
(과거 버전과의 호환성을 위해 false로 두었으니 이를 true로 바꿔주자는 말이다.)  

참고로 이 옵션을 true로 설정하면    
키 생성 기능을 최적화하는 allocationSize 속성을 사용하는 방식이 달라진다.  
allocationSize 는 뒤에 나온다고 하니 일단 냅둔다.  

<property name="hibernate.id.new_generator_mappings" values="true" />   
```

[깔끔하게 정리하신분 사이트](https://yoonbing9.tistory.com/19)도 첨부해본다.  


## 기본키 직접 할당 전략 
`@Id` 어노테이션에 대한 설명 부분이라고 생각해도 좋다.   

**`@Id`가 적용될 수 있는 타입**   
* 자바 기본형(프리미티브 타입)   
* 자바 Wrapper 클래스 형  
* String
* java.util.Date
* java.sql.Date
* java.math.BigDecimal
* java.math.BigInteger 

**기본키 직접 할당 전략**
* `@Id` 필드에 값을 채워서 커밋을 보내는 방식.   
* 만일 값이 없다면 에러를 발생시킨다.(단, 어떤 예외가 발생했는지는 정의되어있지 않다.)

## IDENTITY 전략 
`IDENTITY 전략`은 기본키 생성을 `DB에 위임`하는 것이다.  

```java
코드 입력 부탁
```

**사용 방법**
* `@GeneratedValue(strategy = GenerationType.IDENTITY)`을 `@id` 붙은 필드에 기술한다.   
* `@id`가 붙은 필드의 값이 비어 있어야 한다.
  
**특징**  
* jpa 입장에서는 엔티티를 영속 상태에 만들기 위해선, 기본키를 먼저 알아야한다.    
* 그렇기에, `em.persist()` 시점에 쓰기 지연을 하지않고        
  바로 쿼리를 DB에 날려 `데이터를 등록하고 식별자를 리턴받는다.`             
            
## SEQUENCE      
데이터베이스 시퀀스는       
유일한 값을 순서대로 `생성`하는 데이터베이스 오브젝트다.      
`SEQUENCE` 전략은 이 시퀀스를 사용해서 기본키를 생성하는 전략이다.       
  
```java
코드
```  
`SEQUENCE 전략`은 `strategy`속성 외에도             
`generator`속성을 이용하여 `DB 시퀀스`와 `매핑`을 해야한다.      
여기서 말한 `DB 시퀀스`는 `@SequenceGenerator`를 통해 만들어진 시퀀스를 말한다.       
**한 가지 궁금증은, 이미 존재하는 시퀀스를 사용가능할수도 있다고 생각된다.**      
    
**동작**   
* `em.persistence()`를 호출할 때 먼저, `데이터베이스 시퀀스를 사용해서 식별자를 조회`한다.     
* 조회한 식별자를 `엔티티에 할당한 후`에 `엔티티를 영속성 컨텍스트에 저장`한다.           
* 이후 트랜잭션을 커밋해서 플러시가 일어나면 엔티티를 DB에 저장한다.        
       
### @SequenceGenerator 
  
|속성|기능|기본값|   
|----|----|------|  
|name|식별자 생성기 이름|필수|  
|sequenveName|DB에 등록되어 있는 시퀀스 이름|hibernate_sequence|  
|initialValue|DDL 생성시에만 사용된다, 시퀀스는 DDL을 생성할 때 처음 시작하는 수를 지정한다.|1|   
|allocationSize|시퀀스 한 번 호출에 증가하는 수(성능 최적화에 사용된다.)|50|   
|catalog, schema|DB catalog, schema 이름||    




