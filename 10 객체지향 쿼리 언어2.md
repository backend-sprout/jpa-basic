# 10 객체지향 쿼리 언어2   
## 페치 조인 
`페치 조인`은 SQL에서 이야기하는 조인의 종류는 아니다.   
**`페치 조인`은 JPQL의 성능 최적화를 위해 제공하는 기능이다.**    
   
페치 조인은, **연관된 엔티티나 컬렉션을 한번에 같이 조회하는 기능**으로 **`join fetch` 명령어로 사용할 수 있다.**   
      
### 엔티티 페치 조인   
```
select m
from Member m join fetch m.team
```
페치 조인을 사용해서 회원 엔티티를 조회하면서 연관된 엔티티도 함께 조회하는 `JPQL`이다.
단순히 `join` 옆에 `fetch`를 불였을 뿐이지만 **회원 엔티티와 팀 엔티티를 함께 조회한다.**   
참고로, `m.team`과 같은 코드는 `alias`를 사용할 수 없다.   
  
```sql
SELECT 
    M.*, T.*
FROM MEMBER M
INNER JOIN TEAM T ON M.TEAM_ID=T.ID
```
`엔티티 페치 조인`에서 `JPQL`에서 `select m`으로 회원 엔티티만 선택했는데   
실행된 `SQL`을 보면 `SELECT M.*, T.*`로 회원과 연관된 팀도 함께 조회된 것을 확인할 수 있다.    
즉, `일반 JOIN`은 `SELECT M.*`만 했던 것과 달리 `SELECT M.*, T.*`로 값을 가져온다.   
그리고 `회원`과 `팀 객체`가 **객체 그래프를 유지하면서 조회된 것을 확인할 수 있다.**           
    
```java
String jpql = "select m from Member m join fetch m.team"

List<Member> members = em.createQuery(jpql, Member.class).getResultList();
   
for(Member member : members) {    
    // 페치 조인으로 회원과 팀을 함께 조회해서 지연 로딩이 발생하지 않는다.   
    System.out.println("username = " + member.getUsername() + ", " + 
        "teamname = " + member.getTeam().name());
}
```
```
username = 회원1, teamname = 팀A
username = 회원2, teamname = 팀A
username = 회원3, teamname = 팀B
```   
`회원`과 `팀`을 지연로딩으로 설정했다고 가정해보자.(`fetch = FetchType.LAZY`) 
회원을 조회할 때 페치 조인을 사용해서 팀도 함께 조회했으므로         
연관된 팀 **엔티티는 프록시가 아닌 실제 엔티티가 된다.**               
즉, **지연 로딩으로 설정했음에도 지연 로딩이 일어나지 않는다.**         
(회원 엔티티가 준영속이 되어도 팀은 조회할 수 있다는 장점이 생긴다.)    
    
### 컬렉션 페치 조인   
`1대N 관계`인 컬렉션을 페치 조인해보자.     
     
```   
select t 
from Team t join t.members
where t.name = '팀A'
```
```
SELECT 
    T.*, M.*
FROM TEAM T
INNER JOIN MEMBER M ON T.ID=M.TEAM_ID
WHERE T.NAME = '팀A'
```
컬렉션을 페치 조인한 `JPQL`에서 `select t`로 팀만 선택했는데   
`SQL`을 보면 `T.*, M.*`로 `팀`과 `연관된 회원`도 함께 조회하고 있다.      
 
|ID(PK)|NAME|ID(PK)|TEAM_ID(FK)|NAME|
|------|----|------|-----------|----|
|1|팀A|1|1|회원1|
|1|팀A|2|1|회원2|

`팀A`는 1개이지만, `Team`과 `Member`를 함께 조인하면서    
`회원1의 팀A`, `회원2의 팀A` 이렇게 2개가 조회되었음을 알 수 있다.   

**참고**   
일대다 조인은 결과가 증가할 수는 있지만,      
일대일, 다대일 조인은 결과가 증가하지는 않는다.    

```java
String jpql = "select t from Team t join fetch t.members where t.name = '팀A'";
List<Team> teams = em.createQuery(jpql, Team.class).getResultList();

for(Team team : teams) {
    System.out.println("teamname = " + team.getName() + ", team = " + team);
    for(Member member : team.getMember()) {
        // 페치 조인으로 팀과 회원을 함께 조회해서 지연 로딩 발생 안함
        System.out.println(
            "-> username = " + member.getUserName() + ", member = " + member);
    }
}
```
```
teamname = 팀A, team = Team@0x100
-> username = 회원1, member = Member@0x200
-> username = 회원2, member = Member@0x300
teamname = 팀A, team = Team@0x100
-> username = 회원1, member = Member@0x200
-> username = 회원2, member = Member@0x300
teamname
```
출력 결과를 보면 같은 `팀A`가 2건 조회된 것을 확인할 수 있다.     

### 페치 조인과 DISTINCT   
`SQL`의 `DISTINCT`는 중복된 결과를 제거하는 명령어다.     
`JPQL`의 `DISTINCT`는 `SQL`은 물론 애플리케이션 단에서도 `DISTINCT`를 추가한다.     

```java
select distinct t    
from Team t join fetch t.members    
where t.name = '팀A'        
```   
   
**컬렉션 패치 조인**은 `팀A`가 중복으로 조회된다.  
이를 해결하기 위해서 위와 같이  `DISTINCT` 구문을 사용하면 된다.    

### 페치 조인과 일반 조인의 차이   
**일반 조인**   
```java
select t
from Team t join t.members m
where t.name = '팀A'
```
```sql
SELECT 
    T.* 
FROM TEAM T
INNER JOIN MEMBER M ON T.ID=M.TEAM_ID
WHERE T.NAME = '팀A'

// LAZT or EAGER   
T만 가져왔기에 다시, M을 찾아서 가져온다.  
SELECT 
    M.* 
FROM MEMBER M
INNER JOIN TEAM T ON T.ID=M.TEAM_ID
WHERE TEAM.NAME = '팀A'
```    
일반 조인의 `JPQL`은 **결과를 반환할 때 연관관계까지 고려하지 않는다.**                  
**단지, SELECT 절에 지정한 엔티티만 조회할 뿐이다.**                   
따라서, 예제를 기준으로 말하면 `팀 엔티티만 조회하고 연관된 회원 컬렉션은 조회하지 않는다.`       

**여기서 연관관계는 어떤 역할을 할까? 🤔**        
* LAZY : 프록시로 가져오기에 연관 객체를 가져올 때 쿼리를 호출한다.  
* EAGER : jpql은 단순히 SQL로 변환하여 실행할 뿐이다.      
    그렇기에, 우선은 단순히 한 개의 `엔티티 값`만을 조인해서 가져오고     
    연관 관계가 비었기에 다시 `select`를 통해 값을 가져온다.     
  
**페치 조인**
```   
select t 
from Team t join t.members
where t.name = '팀A'
```
```
SELECT 
    T.*, M.*
FROM TEAM T
INNER JOIN MEMBER M ON T.ID=M.TEAM_ID
WHERE T.NAME = '팀A'
```
이에 비해, 페치조인은 **연관된 객체들을 한번에 가져온다**는 특징이 있다.     

### 페치 조인의 특징과 한계   
페치 조인을 사용하면 `SQL`을 `1번`으로 연관된 엔티티들을 함께 조회할 수 있어서    
**`SQL` 호출 횟수를 줄여 성능을 최적화할 수 있다.**    

```java
@OneToMany(fetch = FetchType.LAZY) // 글로벌 로딩 전략   
```   
위와 같이, **엔티티에 직접 적용하는 로딩 전략은 글로벌 `로딩 전략`이라고 부른다.(애플리케이션 전체에 영향을 미치므로)**      

* `페치 조인` > `글로벌 로딩 전략`  
     
**페치 조인은 글로벌 로딩 전략보다 우선한다.**       
예를들어, 글로벌 로딩 전략을 지연 로딩으로 설정해도        
JPQL에서 페치 조인을 사용하면 페치 조인을 함께 적용해서 조회한다.       
  
최적화를 위해 글로벌 로딩 전략을 즉시 로딩으로 설정하면       
애플리케이션 전체에서 항상 즉시 로딩이 일어난다.        
물론, 일부는 빠를 수는 있지만 전체로 보면 **사용하지 않는 엔티티를 자주 로딩하므로 오히려 성능에 악영향을 미칠 수 있다.**       

따라서 **글로벌 로딩 전략은 될 수 있으면 `지연 로딩`을 사용하고**      
**최적화가 필요하면 `페치 조인`을 적용하는 것이 효율적이다.**      

또한, 페치 조인을 사용하면 연관된 엔티티를 쿼리시점에 조회하므로 지연로딩이 발생하지 않는다.   
따라서, **준영속 상태에서도 객체 그래프를 탐색할 수 있다.**       
**우재의 궁금증 :** `Transactional(readOnly="true")`는 가져오고 준영속으로 만드는 것인가? 🤔 궁금하다.   

**페치 조인의 한계**   
* `페치 조인 대상`에는 별칭을 줄 수 없다.(기준 엔티티는 가능)  
    * 문법상 별칭을 줄수 없고 `SELECT`, `WHERE`, `서브쿼리`에 페치 조인 대상을 사용할 수 없다.   
    * `Hibernate`와 같은 몇몇 `JPA 구현체`들은 페치 조인에 별칭을 지원하기도 한다.   
      단, 구현체마다 다르고 별칭을 잘못 사용하면 무결성이 깨질 수 있고   
      특히 연관된 데이터 수가 달라진 상태에서 2차 캐시에 저장되면  
      다른 곳에서 조회할 때도 연관된 데이터 수가 달라지는 문제가 발생할 수 있다.     
* 둘 이상의 컬렉션을 페치할 수 없다.   
    * 구현체에 따라 사용은 가능하나, `컬렉션1의 수` * `컬렉션2의 수` 카테시안 곱이 만들어지므로 주의해야한다.   
    * `Hibernate` 에서는 에러가 발생한다.   
* 컬렉션을 페치 조인하면 페이징 API를 사용할 수 없다.  
    * `컬렉션(일대다)`이 아닌 `단일 값 연관 필드(일대일, 다대일)`들은 페치 조인을 사용해도 페이징 API를 사용할 수 있다.    
    * `Hibernate`에서 컬렉션을 페치 조인하고 `페이징 API`를 사용하면   
       경고 로그를 남기면서 메모리에서 페이징 처리를 한다.   
       데이터가 적으면 상관없겠지만 데이터가 많으면 성능 이슈와 메모리 초과 예외가 발생할 수 있어서 위험하다.   

페치 조인은 SQL 한 번으로 연관된 여러 엔티티를 조회할 수 있어서 성능 최적화에 상당히 유용하다.     
하지만, 몇몇 한계점들이 존재하기에 모든 것을 페치 조인으로 해결할 수는 없다.   
     
페치 조인은 객체 그래프를 유지할 때 사용하면 효과적이다.       
반면에 여러 테이블을 조인해서 엔티티가 가진 모양이 아닌 전혀 다른 결과를 내야한다면      
억지로 페치조인을 사용하기보다는 여러 테이블에서 필요한 필드들만 조회해서 DTO로 반환하는것이 더 효과적일 수 있다.     

## 경로 표현식  
경로 표현식을 쉽게 설명하면, `.`을 찍어 `객체 그래프`를 탐색하는 것이다.      
 
```java   
select m.username  
from Member m      
    join m.team t  
    join m.orders o   
where t.name = '팀A'      
```

위 코드에서 `m.username`, `m.team`, `m.orders`, `t.name` 이 경로 표현식을 사용한 것이다.   

### 경로 표현식 용어 정리   
* **상태 필드 :** 단순한 값을 저장하기 위한 필드(필드 or 파라미터)
* **연관 필드 :** 연관관계를 위한 필드, 임베디드 타입 포함(필드 or 파라미터)
    * 단일 값 연관 필드: `@ManyToOne`, `@OneToOne`, 대상이 엔티티  
    * 컬렉션 값 연관 필드 : `@OneToMany`, `@ManyToMany`, 대상이 컬렉션   
   
상태 필드는 단순히 값을 저장하는 필드고    
연관 필드는 객체 사이의 연관관계를 맺기 위해 사용하는 필드다.   

```java
@Entity
public class Member {
    
    @Id @GeneratorValue
    private Long id;
    
    @Column(name = "name")   
    private String username; // 상태 필드  
    private Integer age; // 상태 필드  
    
    @ManyToOne(..)
    private Team team; // 연관 필드(단일 값 연관 필드)
    
    @OneToMany(..)  
    private List<Order> orders; // 연관 필드(컬렉션 값 연관 필드)  
    
}
```

* 상태 필드 : t.username, t.age
* 단일 값 연관 필드 : m.team
* 컬렉션 값 연관 필드 : m.orders

### 경로 표현식과 특징     
JPQL에서 경로 표현식을 사용해서 경로 탐색을 하려면      
다음 3가지 경로에 따라 어떤 특징이 있는지 이해해야한다.     

* 상태 필드 경로 :    
  경로 탐색의 끝(더는 탐색할 수 없다.)   
* 단일 값 연관 경로 : 
  **묵시적으로 내부 조인이 일어난다.**
  단일 값 연관 경로는 계속 탐색할 수 있다.     
* 컬렉션 값 연관 경로 : 
  **묵시적으로 내부 조인이 일어난다.**
  **더는 탐색할 수 없다.**  
  단 FROM 절에서 조인을 통해 별칭을 얻으면 별칭으로 탐색할 수 있다.   
  
#### 상대 필드 경로 탐색   
```java
select m.username, m.age from Member m
```
```sql
SELECT m.name, m.age
FROM MEMBER m;
```
`상대 필드 경로 탐색`은 단순한 값을 저장하기 위한 필드이기에 더는 탐색할 수 없다.   

##### 단일 값 연관 경로 탐색   
```java
select o.member from Order o
```
```sql
SELECT m.*  
FROM ORDERS o   
INNER JOIN MEMBER m
ON o.member_id = m.id
```  
`o.member`를 통해 `주문`에서 `회원`으로 단일 값 연관 필드로 경로 탐색을 했다.      
**단일 값 연고나 필드로 경로 탐색을 하면 SQL에서 내부 조인이 일어나는데, 이것을 묵시적 조인이라고 한다.**         
즉, `JPQL`에서는 조인을 사용하지 않았지만 `객체 그래프 탐색을 위해 조인`이 되기에 이를 묵시적 조인이라고 하는 것이다.      
참고로, **묵시적 조인은 모두 내부 조인**이며, **외부 조인을 이용하고자 한다면 명시적으로 JOIN 키워드를 이용**해야한다.      

* **명시적 조인 :** JOIN을 직접 적어주는 것   
  `SELECT m FROM Member m JOIN m.team t`
* **묵시적 조인 :** 경로 표현식에 의해 묵시적으로 조인이 일어나는 것, 내부(INNER) 조인만 가능하다.   
  `SELECT m.team FROM Member m`   

```java
select o.member.team
from Order o
where o.product.name = 'productA' and o.address.city = 'JINJU'
```    
```sql
SELECT t.*   
FROM ORDERS o
INNER JOIN Member m on o.member_id = m.id
INNER JOIN TEAM t on m.team_id=t.id
INNER JOIN PRODUCT p on o.product_id=p.id
WHERE p.name='producyA' and o.city='JINJU'
```
  
위 코드를 보면 `내부 조인(INNER JOIN)`이 총 3번 일어났다.    
이는 `단일값 연관관계 필드`의 `경로 탐색` 덕분이며 이처럼 연속적인 탐색이 가능하다.   

참고로, `o.address`처럼 임베디드 타입에 접근하는 것도 **단일 값 연관 경로 탐색**이지만     
**주문 테이블에 이미 포함되어 있으므로 조인이 발생하지는 않는다.**       

#### 컬렉션 값 연관 경로 탐색  
`JPQL`에서 가장 많이 하는 실수 중 하나가 **컬렉션 값에서 경로 탐색을 시도하는 것**이다.    

```
select t.members from Team t // 성공
select t.members.username from Team t // 실패   
```
`t.members`처럼 1단계는 탐색이 가능하지만,     
`t.members.username` 와 같이 컬렉션에서 경로 탐색을 시작하는 것은 허용하지 않는다.      
만약 컬렉션에서 경로 탐색을 하고 싶으면 다음 코드처럼 조인을 사용해서 새로운 별칭을 획득해야한다.     
  
```java
select m.username from Team t join t.members m
``` 
페치 조인이 아니기에 이런 별칭을 얻는 작업은 가능하다.      
`join t.members m`으로 컬렉션에 새로운 별칭을 얻었다.     
이제 별칭 m부터 다시 경로 탐색을 할 수 있다.     

```
select t.members.size from Team t
```
참고로 컬렉션의 크기를 구할 수 있는 `size` 라는 특별한 기능을 사용할 수 있다.      
`size`를 사용하면 `COUNT 함수`를 사용하는 `SQL`로 적절히 변환된다.      

### 경로 탐색을 사용한 묵시적 조인시 주의사항   
경로 탐색을 사용하면 묵시적 조인이 발생해서 SQL에서 내부조인이 일어난다.   

* **항상 내부 조인이다.**
* 컬렉션은 경로 탐색의 끝이다.   
  컬렉션에서 경로 탐색을 하려면 명시적으로 조인을 해서 별칭을 얻어야 한다.   
* 경로 탐색은 주로 `SELECT`, `WHERE`절에서 사용하지만,     
  묵시적 조인으로 인해 `SQL`의 `FROM` 절에 영향을 준다.        
    
조인이 성능상 차지하는 부분은 아주 크다.     
묵시적 조인은 조인이 일어나는 상황을 한눈에 파악하기 얼벼다는 단점이 있다.      
따라서 단순하고 성능에 이슈가 없으면 크게 문제가 안되지만 성능이 중요하면        
분석하기 쉽도록 **묵시적 조인보다는 명시적 조인을 사용하자**   

## 다형성 쿼리   
`JPQL`로 부모 엔티티를 조회하면 그 자식 엔티티도 함께 조회된다.    

```java
@Entity
@Inheritance(strategy = Inheritance.Type.SINGLE_TABLE)
@DiscriminatorColumn(name = "DTYPE") 
public static class Item {...}

@Entity
@DiscriminatorValue("B")  
public class Book extends Item {
    
    ...
    private String author;
}
// Album, Movie 생략  
```  
다음과 같이 조회하면 `Item`의 자식도 함께 조회된다.    

```java
List resultList = 
    em.createQuery("select i from Item i").getResultList();
```

단일 테이블 전략을 사용할 때 실행되는 SQL은 다음과 같다.   

```sql
SELECT * FROM ITEM
```
   
조인 전략을 사용할 때 실행되는 SQL은 다음과 같다.    

```sql
SELECT 
    i.ITEM_ID, i.DTYOE, i.name, i.price, i.stockQuantity,
    b.author, b.isbn,
    a.artist, a.etc,
    m.actor, m.director
FROM 
    Item i
LEFT OUTER JOIN 
    Book b on i.ITEM_ID=b.ITEM_ID
LEFT OUTER JOIN 
    Album a on i.ITEM_ID=a.ITEM_ID
LEFT OUTER JOIN 
    Movie m on i.ITEM_ID=m.ITEM_ID    
```

### TYPE    
`TYPE`은 엔티티의 상속 구조에서 조회 대상을 특정 자식 타입으로 한정할 때 주로 사용한다.   

**ITEM중에 Book, Movie 를 조회하라**
```java
// JPQL
select i from Item i
where type(i) IN (Book, Movie)

// SQL
SELECT i FROM Item i
WHERE i.DTYPE in ('B', 'M')
```

### TREAT(JPA 2.1)   
`TREAT`는 `JPA 2.1`에 추가된 기능인데 자바의 타입 캐스팅과 비슷하다.   
상속 구조에서 부모 타입을 특정 자식 타입으로 다룰 때 사용한다.   
     
`JPA 표준`은 `FROM`, `WHERE` 절에서 사용할 수 있지만,      
`Hibernate` 는 `SELECT 절`에서도 `TREAT`를 사용할 수 있다.    

**부모인 Item과 자식 Book이 있다.**   
```java
// JPQL
select i from Item i where treat(i as Book).author = 'kim'

// SQL
select i.* from Item i
where 
    i.DTYPE='B'
    and i.author='kim'
```
`JPQL`을 보면 `treat`를 사용해서      
`부모 타입인 Item`을 `자식 타입인 Book`으로 다룬다.      
따라서 `author` 필드에 접근할 수 있다.      
  
  























## 페치 조인과 일반 조인의 차이   
일반 조인은 결과를 반환할 때 연관관계까지는 고려하지 않는다.    
단지 SELCT절에 지정한 엔티티만 조회할 뿐이다.   
따라서 Parent엔티티만 조회할 때 그와 연관된 Child엔티티는 조회하지 않는다.
반면에 페치 조인을 사용하면 연관된 엔티티도 함께 조회하여 결과를 얻어 올 수 있다.
   
   
# N+1?


**N+1**
```
select member from Member m (order 연관관계(Member 1: N Order)를 가지고 있다.)  
```
`em.find()` 와 달리 `JPQL`은 해당 언어를 SQL로만 바꾸는 역할을 한다.   
즉, `em.find()`는 즉시로딩이라 하더라도 `JOIN`을 진행하지만,  
`JPQL`은 `SELECT`구문으로 진행이 된다.  
이때, 연관관계가 `EAGER`타입이라면 값을 가져옴과 동시에 초기화가 되어 있어야한다.  
그러므로 `select`를 이용하여 해당 FK(아이디) 값을 가진 `Order`를 가지고 온다.    

즉, Member 1개 가져올때 한개의 Order를 다시 SELECT로 검색해서 찾아오는 것이다.  
그렇기에 처음 전체 Member 를 가져오는 구문, 
각 Member 별 Order를 가져오는 N이 더해져서 N+1이 된다.   

