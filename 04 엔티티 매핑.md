# 엔티티 매핑  
 
JPA를 사용함에 있어 가장 중요한 일은 **엔티티**와 **테이블**을 매핑하는 과정이다. 
따라서 매핑 어노테이션을 숙지하고 사용해야 한다.

* 객체와 테이블 : `@Entity`, `@Table`  
* 기본 키 매핑 : `@Id`
* 필드와 컬럼 매핑 : `@Column`  
* 연관관계 매핑 : `@ManyToOne`, `@JoinColumn`   

# @Entity
`@Entity`붙은 클래스는 JPA가 관리하는 클래스로 지정하는 것으로   
JPA를 사용해서 테이블과 매핑할 클래스는 `@Entity` 어노테이션을 필수로 붙여야한다.   
그리고 이러한 클래스를 우리는 `엔티티`라고 부른다.  

|속성|기능|기본값|
|----|----|------|
|name|JPA에서 사용할 엔티티 이름을 지정한다.<br>보통 기본값인 클래스 이름을 사용하지만,<br>다른 디렉토리에 동일한 이름의 클래스가 있다면 충돌이 난다.<br>이 같은 경우는 해당 속성 값을 통해 이름을 변경해주자|클래스의 이름을 그대로 사용한다.|     

**`@Entity` 주의사항**   
* 기본 생성자는 필수다.(파라미터가 없는 / public, protected 로만 가능)  
* `final 클래스`, `enum`, `interface`, `inner 클래스`에는 사용할 수 없다.   
* 저장할 필드에 `final`을 사용하면 안 된다.    
  
이러한 주의사항 때문에 `디폴트 생성자`를 고려해볼 수는 있지만,      
아시다시피 다른 생성자가 존재하면 자동으로 추가되지 않으므로     
`기본 생성자`는 명확히 기술해주도록 하는 것이 좋다.     
    
**궁금증, 정말로 final을 사용할 수는 없는 것일까? 🤔**   
* 사실, 엔티티 클래스에도 `final`을 사용할 수 있으며 기본적인 동작에는 문제가 없다. 
* 단, JPA는 지연로딩(lazy-loading)시에 proxy 객체를 만드는데 이때 사용이 불가능해진다.   
    * 지연로딩은 `proxy 객체`를 만들어 놓았다가 실제 엔티티를 사용할 때 쿼리를 날려서 값을 가져온다.      
    * 그렇기에 이러한 `proxy 객체`에서 문제가 발생하기에 사용하지 말라고 권장하는 것이다.
* 참고로 `final`을 사용할 경우 코틀린에서는 문제가 크게 발생한다고 한다.        
* [참고](https://effectivesquid.tistory.com/entry/Kotlin-JPA-%EC%82%AC%EC%9A%A9%EC%8B%9C-Entity-%EC%A0%95%EC%9D%98)

