# 10 객체지향 쿼리 언어2   

## 페치 조인 
`페치 조인`은 SQL에서 이야기하는 조인의 종류는 아니다.   
**`페치 조인`은 JPQL의 성능 최적화를 위해 제공하는 기능이다.**    
   
페치 조인은, **연관된 엔티티나 컬렉션을 한번에 같이 조회하는 기능**으로 **`join fetch` 명령어로 사용할 수 있다.**   
      
**엔티티 페치 조인**  
```
select m
from Member m join fetch m.team
```
페치 조인을 사용해서 회원 엔티티를 조회하면서 연관된 엔티티도 함께 조회하는 `JPQL`이다.
단순히 `join` 옆에 `fetch`를 불였을 뿐이지만 **회원 엔티티와 팀 엔티티를 함께 조회한다.**   
참고로, `m.team`과 같은 코드는 `alias`를 사용할 수 없다.   
  
```sql
SELECT 
    M.*, T.*
FROM MEMBER M
INNER JOIN TEAM T ON M.TEAM_ID=T.ID
```
`엔티티 페치 조인`에서 `JPQL`에서 `select m`으로 회원 엔티티만 선택했는데   
실행된 `SQL`을 보면 `SELECT M.*, T.*`로 회원과 연관된 팀도 함께 조회된 것을 확인할 수 있다.    
즉, `일반 JOIN`은 `SELECT M.*`만 했던 것과 달리 `SELECT M.*, T.*`로 값을 가져온다.   
그리고 `회원`과 `팀 객체`가 **객체 그래프를 유지하면서 조회된 것을 확인할 수 있다.**           
    
```java
String jpql = "select m from Member m join fetch m.team"

List<Member> members = em.createQuery(jpql, Member.class).getResultList();
   
for(Member member : members) {    
    // 페치 조인으로 회원과 팀을 함께 조회해서 지연 로딩이 발생하지 않는다.   
    System.out.println("username = " + member.getUsername() + ", " + 
        "teamname = " + member.getTeam().name());
}
```
```
username = 회원1, teamname = 팀A
username = 회원2, teamname = 팀A
username = 회원3, teamname = 팀B
```   
`회원`과 `팀`을 지연로딩으로 설정했다고 가정해보자.(`fetch = FetchType.LAZY`) 
회원을 조회할 때 페치 조인을 사용해서 팀도 함께 조회했으므로         
연관된 팀 **엔티티는 프록시가 아닌 실제 엔티티가 된다.**               
즉, **지연 로딩으로 설정했음에도 지연 로딩이 일어나지 않는다.**         
(회원 엔티티가 준영속이 되어도 팀은 조회할 수 있다는 장점이 생긴다.)    

**컬렉션 페치 조인**    
`1대N`관계인 컬렉션을 페치 조인해보자.   








## 페치 조인과 일반 조인의 차이   
일반 조인은 결과를 반환할 때 연관관계까지는 고려하지 않는다.    
단지 SELCT절에 지정한 엔티티만 조회할 뿐이다.   
따라서 Parent엔티티만 조회할 때 그와 연관된 Child엔티티는 조회하지 않는다.
반면에 페치 조인을 사용하면 연관된 엔티티도 함께 조회하여 결과를 얻어 올 수 있다.
   
   
# N+1?


**N+1**
```
select member from Member m (order 연관관계(Member 1: N Order)를 가지고 있다.)  
```
`em.find()` 와 달리 `JPQL`은 해당 언어를 SQL로만 바꾸는 역할을 한다.   
즉, `em.find()`는 즉시로딩이라 하더라도 `JOIN`을 진행하지만,  
`JPQL`은 `SELECT`구문으로 진행이 된다.  
이때, 연관관계가 `EAGER`타입이라면 값을 가져옴과 동시에 초기화가 되어 있어야한다.  
그러므로 `select`를 이용하여 해당 FK(아이디) 값을 가진 `Order`를 가지고 온다.    

즉, Member 1개 가져올때 한개의 Order를 다시 SELECT로 검색해서 찾아오는 것이다.  
그렇기에 처음 전체 Member 를 가져오는 구문, 
각 Member 별 Order를 가져오는 N이 더해져서 N+1이 된다.   

