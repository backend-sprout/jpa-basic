# 인강을 기준으로 간단히 정리  
> 추후에 수정예정입니다.   
## 프록시
   
**em.find();**   
* 데이터베이스를 통해서 실제 엔티티를 받아온다.  
       
**em.getReference();**      
* 데이터베이스 조회를 미루는 가짜(프록시) 엔티티 객체 조회        
* 값이 실제 사용되는 시점에서 DB에서 target 참조 값을 가져온다.  
* 이후 메서드를 호출할 때도 target을 통해 실제 객체의 메서드를 호출한다.   
    
**프록시 객체의 초기화**    
1. getName() 실행 -> (target.getName()) 
2. 영속성 컨텍스트에, 초기화 요청 
3. 없으면 DB 조회
4. 실제 엔티티 생성
5. taget.getName()을 통해 실제 엔티티의 getName()실행 
    * 여기서 중요한점은 프록시는 쭉 프록시라는 점이다.   
   
**프록시의 특징**   
* 프록시 객체는 처음 사용할 때 한 번만 초기화 (영속성 컨텍스트 캐싱 주의)    
* 프록시 객체를 초기화 할 때,   
  프록시 객체가 실제 엔티티로 바뀌는 것은 아니다.   
  초기화 되면서 프록시 객체를 통해서 실제 엔티티에 접근한다.      
  즉, 프록시로 초기화되면 쭉 프록시로 남아 있는 것이다.  
* 프록시 객체는 원본 엔티티를 상속받는다.  
  따라서 타입 체크시 주의해야한다. ( `==` 비교 실패, 대신 `instanceof` 사용)  
* 영속성 컨텍스트에 찾는 엔티티가 있으면 em.getReference()를 호출해도 실제 엔티티 반환한다.     
* 영속성 컨텍스트의 도움을 받을 수 없는 `준영속 상태`일 때, 프록시를 초기화하면 문제 발생        
   

**재밌는 상황 1**   
```java
m1 = em.find()
m2 = em.getReference()

m1 == m2 -> true
m2.getClass() -> 레퍼런스 엔티티  
```
JPA에서 `같은 키 ID`로 조회하는 객체들에 한하여 동일성을 보장한다.(트랜잭션 내에서)  
즉 1 이라는 ID를 가지고 `find()`를 하거나, `getReference()`를 한 결과는 같다.  

```java
m2 = em.getReference()
m1 = em.find()

m1 == m2 -> true
m2.getClass() -> 레퍼런스 엔티티  
```
프록시가 한번 조회되면 그다음에는 프록시가 반환된다.  


**준영속**   
```java
m1 = em.getReference()

em.close() 또는 em.detach(m1)

m1.getUserName() -> ?
에러 발생 -> 참조 되기전에 detach 되었으므로 초기화 불가  
```   

**프록시 확인**   
* 프록시 인스턴스의 초기화 여부 확인  
    * PersistenceUnitUtil.isLoaded(Object entity) 
* 프록시 클래스 확인 방법  
    * entity.getClass().getName()
* 프록시 강제 초기화 
    * org.hibernate.initailize(entity);
    * 참고, JPA 표준은 강제 초기화 없음 
        * 강제호출 member.getName();  
   
## 지연로딩   
Member 를 조회할 때 Team도 함께 조회해야되나?   
member만 사용하면 굳이 Team은 조회하지 않아도 되지 않나?     
  
연관관계 매핑에서    
`fetch = FetchType.LAZY)` : 지연로딩 -> 내부 연관 객체를 프록시로 가져온다.   
`fetch = FetchType.)`

