# 인강을 기준으로 간단히 정리  
> 추후에 수정예정입니다.   
   
**em.find();**   
* 데이터베이스를 통해서 실제 엔티티를 받아온다.  
       
**em.getReference();**      
* 데이터베이스 조회를 미루는 가짜(프록시) 엔티티 객체 조회        
* 값이 실제 사용되는 시점에서 DB에서 target 참조 값을 가져온다.  
* 이후 메서드를 호출할 때도 target을 통해 실제 객체의 메서드를 호출한다.   
    
**프록시 객체의 초기화**    
1. getName() 실행 -> (target.getName()) 
2. 영속성 컨텍스트에, 초기화 요청 
3. 없으면 DB 조회
4. 실제 엔티티 생성
5. taget.getName()을 통해 실제 엔티티의 getName()실행 
    * 여기서 중요한점은 프록시는 쭉 프록시라는 점이다.   
   
**프록시의 특징**   
* 프록시 객체는 처음 사용할 때 한 번만 초기화 (영속성 컨텍스트 캐싱 주의)    
* 프록시 객체를 초기화 할 때,   
  프록시 객체가 실제 엔티티로 바뀌는 것은 아니다.   
  초기화 되면서 프록시 객체를 통해서 실제 엔티티에 접근한다.      
  즉, 프록시로 초기화되면 쭉 프록시로 남아 있는 것이다.  
* 프록시 객체는 원본 엔티티를 상속받는다.  
  따라서 타입 체크시 주의해야한다. ( `==` 비교 실패, 대신 `instanceof` 사용)  
 
**재밌는 상황 1**   
```java
m1 = em.find()
m1사용
m2 = em.getReference()

m1 == m2 -> true
m2.getClass() -> 원조 엔티티  
```
JPA에서 `같은 키 ID`로 조회하는 객체들에 한하여 동일성을 보장한다.(트랜잭션 내에서)  
즉 1 이라는 ID를 가지고 `find()`를 하거나, `getReference()`를 한 결과는 같다.  


