트랜잭션과 락, 2차캐시
=======================
# 트랜잭션과 격리 수준 

**트랜잭션은 ACID라 하는 원자성, 일광성, 격리성, 지속성을 보장해야한다.**   

* **원시성(Atomicity) :** 트랜잭션 내에서 실행한 작업들은 마치 하나의 작업인 것처럼 모두 성공하거나 모두 실패해야 한다.    
* **일관성(Consistency) :** 모든 트랜잭션은 일관성 있는 데이터베이스 상태를 유지해야한다.      
  예를 들어 데이터베이스에서 정한 무결성 제약 조약 조건을 항상 만족해야한다.     
* **격리성(Isolation) :** 동시에 실행되는 트랜잭션들이 서로에게 영향을 미치지 않도록 격리한다.     
  예를 들어 동시에 같은 데이터를 수정하지 못하도록 해야 한다.       
  격리성은 동시성과 관련된 성능 이슈로 인해 격리 수준을 선택할 수 있다.       
* **지속성(Durabillity) :** 트랜잭션을 성공적으로 끝내면 그 결과가 항상 기록되어야 한다.    
  중간에 시스템에 문제가 발생해도 데이터베이스 로그 등을 사용해서 성공한 트랜잭션 내용을 복구해야한다.     
   
ACID 특징 중 문제는 격리성이다.    
트랜잭션간에 격리성을 완벽히 보장하려면 트랜잭션을 거의 차례대로 실행해야한다.     
다만, 이 같은 방식을 취하면 동시성 처리 성능 속도가 매우 나빠진다.      
 
이 같은 문제를 해결하고자 ANSI 표준은 트랜잭션의 격리 수준을 4단계로 나누어 정의했다.    

**트랜잭션 격리 수준**
* READ UNCOMMITED : 커밋되지 않은 읽기      
* READ COMMITTED : 커밋된 읽기 
* REPEATABLE READ : 반복 가능한 읽기 
* SERIALIZABLE : 직렬화 가능  

위부터 아래 순서대로 `READ UNCOMMITED`의 격리 수준이 낮고 `SERIALIZABLE`의 격리 수준이 가장 높다.   
격리 수준이 낮을수록 동시성은 증가하지만 다양한 문제가 발생할 가능성이 높다.    

|격리 수준|DIRTY READ|NON-REPEATABLE READ|PHANTOM READ|
|--------|------------------------------|------------|
|UNCOMMITED|O|O|O|
|READ COMMITTED||O|O|
|REPEATABLE READ|||O|
|SERIALIZABLE||||
  
격리 수준에 따른 문제점은 아래와 같다.   

* DIRTY READ   
* NON-REPEATBLE READ(반복 가능한 읽기)    
* PHANTOM READ   

## READ UNCOMMITTED 
커밋하지 않은 데이터를 읽을 수 있다.   

```
트랜잭션1이 데이터를 수정하고 있고 커밋하지 않은 상태      
트랜잭션2가 수정중인 데이터를 조회할 수 있다.         
이러한 동작을 허용하는 것이 바로 READ UNCOMMITTED 이다.   
```
  
트랜잭션2가 DIRTY READ한 데이터를 사용하는데        
트랜잭션1을 롤백하면 데이터 정합성에 심각한 문제가 발생할 수 있다.       

