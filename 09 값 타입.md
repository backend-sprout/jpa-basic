# JPA 타입 분류
`JPA`의 데이터 타입을 가장 크게 분류하면 `엔티티 타입`과 `값 타입`으로 나눌 수 있다.     

**엔티티 타입**
* `@Entity`로 정의하는 객체         
* 식별자를 통해 지속해서 **추적할 수 있다.**
* 식별자를 변경하지 않는 한, 내부 값을 변경해도 식별자를 통해 가져올 수 있다.
      
**값 타입**    
* `int`, `Integer`, `String` 등등의 자바 기본 타입 또는 객체            
* `값 타입`은 식별자가 없고 숫자나 문자로만 이루어져있어 **추적할 수 없다.**               
* 숫자 `100` -> `200` 으로 변경한다 가정하면, 완전히 다른 값으로 대체된 것이다.      
   
비유하자면, `엔티티 타입`은 `살아있는 생물`이고 `값 타입`은 단순한 수치 정보다.   
     
* **기본 값 타입**   
  * 자바 기본 타입
  * 래퍼 클래스
  * String
* **임베디드 타입(복합 값 타입)**  
* **컬렉션 값 타입**    
  
**기본 값 타입**은, 자바가 제공하는 `기본 데이터 타입`이다.      
**임베디드 타입**은, JPA에서 `사용자가 직접 정의한 값` 타입이다.     
**컬렉션 값 타입**은, `하나 이상의 값` 타입을 저장할 때 사용한다.     
   
# 기본 값 타입   

**프리미티브**
```java
int a = 20;
int b = a;

b = 10

System.out.println("a :" + a);
System.out.println("b :" + b);

// 결과  
a : 20
b : 10
```
  
자바에서 `int`, `double`과 같은 `프리미티브 타입은 절대 공유되지 않는다.`           
예를 들어 `a=b`와 같은 코드는 `b`를 직접적으로 사용하는 것이 아니라, `b`의 값을 **복사**해 `a`에 입력한다.   
그렇기에 기존 값을 변경시키는 것이 아니라, 다른 값으로 대체되는 것이며 이로인해 사이드 이펙트는 일어나지 않는다.  
  
**래퍼클래스(불변)**
```java
Integer a = new Integer(20);
Integer b = a;

// a.setValeu(10); -> 이런 메서드는 존재하지 않는다.   

System.out.println("a :"+ a);
System.out.println("b :"+ b);
```

프리미티브 외에도 `Integer`와 같은 래퍼 클래스나 `String`과 같은 특수한 클래스도 있다.      
이것들은 객체지만 자바 언어에서 기본 타입처럼 사용할 수 있게 지원하므로 기본값 타입으로 정의했다.       
다만, 이들은 `객체`이기 때문에 서로간에 **공유는 가능하다.**     
그럼에도 우리는 이전에 `Long`과 같은 래퍼 클래스 타입을 `id`값으로 사용했다. **그 이유는 뭘까? 🤔**   
   
이는 `불변 객체`이기에 가능했던 것이다.    
**불변 객체란** 자신이 소유한 값을 변경할 수 없는 값이다.     
위 코드에서도 자신의 값을 변경할 수 있는 메서드(방법)이 없다는 것을 알 수 있다.    
만약 다른 값으로 사용하고 싶다면?, **새로운 객체를 참조하는 방식으로 사용해야한다.**      
즉, 그렇기에 이런 `불변 객체`들은 `JPA`를 사용함에 있어 아주 유용한 방식이 된다.     
    
정리하자면, 불변 객체는 다른 참조변수끼리 **공유는 가능**하지만, **변경은 불가능**하다.         
        
**기본 값 타입 특징**       
* 생명 주기를 엔티티에 의존하고 있다.         
* 값 타입은 공유하면 안 된다. (사이드 이펙트가 일어나지 않아야한다.)       
    * 프리미티브 타입은, 공유가 아닌 복사로 이 같은 특징에 알맞다.           
    * 래퍼 타입은, 공유는 가능하지만 복사가 아니기에 사용 가능하다.    
        
# 임베디드 타입(복합값 타입)     
`JPA`에서는 새로운 값 타입을 직접 정의할 수 있으며 이를 `임베디드 타입`이라 부른다.     
주로 기본 값 타입을 모아서 만들어진 복합 값 타입이라고도 한다. (기본 값이 아니면 사이드이펙트 발생하기에)            
               
**기본값 타입**  
```java
@Entity
public class Member {
    
    @Id @GeneratedValue
    private Long id;
    private String name;
    
    // 근무 기간
    @Temporal(TemporalType.DATE) startDate;
    @Temporal(TemporalType.DATE) endDate;
    
    // 집 주소 표현
    private String city;
    private String street;
    private String zipcode;
    // ...
}
```
위 엔티티를 바라봤을 때 아래와 같은 특징을 도출할 수 있다.   

* 회원 엔티티 : `이름`, `근무 시작일`, `근무 종료일`, `주소 도시`, `주소 번지`, `주소 우편 번호`    
   
하지만, 이는 단순히 필드를 풀어서 설명한 것일 뿐이다.    
이것 보다는 아래와 같이 설명하는 것이 더 좋을 것이다.   
   
* 회원 엔티티 : `이름`, `근무 기간`, `집 주소`   
   
회원이 상세한 데이터를 그대로 가지고 있는 것은 **`객체지향적이지 않으며`, 응집력만 떨어뜨린다.**        
대신에 `근무 기간`, `주소` 같은 타입이 있다면 코드가 더 명확해질 것이다.            
즉, `DB`를 위해 필드를 풀어 해치지말고,    
이들을 `하나의 클래스`로 만들어서 `객체지향적이며 응집력이 높도록 관리` 해보자는 뜻이다.                
       
**값 타입 전용 회원 엔티티**
```java
@Entity
public class Member {
    
    @Id @GeneratedValue
    private Long id;
    private String name;
    
    @Embedded Period workPeriod;    // 근무 기간 
    @Embedded Address homeAddress;  // 집 주소  
    // ...
}
```
**Period**
```java
@Embeddable
public class Period {
    
    @Temporal(TemporalType.DATE) startDate;
    @Temporal(TemporalType.DATE) endDate;
    
    public boolean isWork(Date date) {
        // ...값 타입을 위한 메서드를 정의할 수 있다.   
    }
}
```

**Address**
```java
@Embeddable
public class Address {
    
    @Column(name="city)
    private String city;
    private String street;
    private String zipcode;
    // ..
}
```
분리된 클래스들을 통해 엔티티(객체)가 보다 `의미있어지게 되었고`   
`가독성`과 `재사용성`은 물론, 각각의 클래스들은 **응집력이 높아진 상태**임을 확인할 수 있다.       
     
임베디드 타입을 사용하려면 다음 2가지 어노테이션이 필요하다.      
      
* **@Embeddable :** 값 타입을 정의하는 곳에 표시한다.     
* **@Embedded :** 값 타입을 사용하는 곳에 표시한다.     
   
그리고 **임베디드 타입 클래스는 `기본 생성자`가 필수다.**      
(참고로 JPA에서 [생성자를 기술해야하는 이유](https://dundung.tistory.com/222)에 대해서 정리를 해보았다.)    
임베디드 타입을 포함한 모든 값 타입은 **엔티티의 생명주기에 의존**하므로           
엔티티와 임베디드 타입의 관계를 `UML` 로 표현하자면 `컴포지션 관계`가 된다.        
           
**임베디드 타입의 장점**    
* 재사용   
* 높은 응집도    
* `Period.isWork()` 처럼 해당 값 타입만 사용하는 **의미있는 메서드를 만들 수 있다.**       
* **임베디드 타입을 포함한 모든 값 타입은, 값 타입을 소유한 엔티티에 생명주기를 의존한다.**      

## 임베디드 타입과 테이블 매핑   
임베디드 타입을 데이터베이스 테이블에 매핑하는 방법을 알아보자   

[사진]()   

임베디드 타입은 `엔티티의 값`일 뿐이다.       
따라서 값이 속한 엔티티의 테이블에 매핑한다.      
         
사실, 임베디드 타입을 사용하기 전과 후에 매핑하는 테이블은 같다.           
즉, 임베디드 타입 덕분에 객체와 테이블을 아주 세밀하게 매핑하는 것이 가능하다.        
잘 설계한 ORM 애플리케이션은 매핑한 테이블의 수보다 클래스의 수가 더 많다.    
  
ORM을 사용하지 않고 개발하면 테이블 컬럼과 객체 필드를 대부분 1:1로 매핑한다.   
주소나 근무기간 같은 값 타입 클래스를 만들어서 더 객체지향적으로 개발하고 싶어도   
SQL을 직접 다루면 테이블 하나에 클래스 하나를 매핑하는 것도 고단한 작업인데  
테이블 하나에 여러 클래스를 매핑하는 것은 상상하기도 싫을 것이다.    

이런 지루한 작업은 JPA에 맡기고 더 세밀한 객체지향 모델을 설계하는 데 집중하자   

**참고**
UML에서의 `임베디드 값` 타입은 단순하게 표현될 수 있다.  

[사진]()  
   
## 임베디드 타입과 연관관계  
임베디드 타입은 값 타입을 포함은 물론, **엔티티를 참조할 수 있다.**     

```java
@Entity
public class Memebr {
    
    @Embadded Address adress;
    @Embadded PhoneNumber phoneNumber;
    
    // ...
}
```

**Address**
```java
@Embeddable 
public class Address {
    String street;
    String city;
    String state;
    @Embedded Zipcode zipcode;
}
```
**Zipcode**
```java
@Embeddable 
public class Zipcode {
    String zip;
    String plusFour;
}
```
**PhoneNumber**
```java
@Embeddable 
public class PhoneNumber {
    String areaCode;
    String localNumber;
    @ManyToOne PhoneServiceProvider provider; // 엔티티 참조  
    ... 
}
```
**PhoneServiceProvider**
```java
@Entity 
public class PhoneServiceProvider {
    @Id String name; 
    ...
}
```


## @AttribuiteOverride : 속성 재정의   
임베디드 타입에 정의한 매핑정보를 재정의하려면 엔티티에 `@AttributeOverride`를 사용하면 된다.   
예를 들어 회원에게 주소가 하나 더 필요하면 어떻게 해야할까?   

**Member**
```java
@Entity
public class Member {
    
    @Id @GeneratedValue
    private Long id;
    private String name;
    
    @Embadded Address homeAddress;
    @Embadded Address companyAddress;
    
}
```


  

