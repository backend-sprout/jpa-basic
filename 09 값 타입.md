# JPA 타입 분류
`JPA`의 데이터 타입을 가장 크게 분류하면 `엔티티 타입`과 `값 타입`으로 나눌 수 있다.     

**엔티티 타입**
* `@Entity`로 정의하는 객체         
* 식별자를 통해 지속해서 **추적할 수 있다.**
* 식별자를 변경하지 않는 한, 내부 값을 변경해도 식별자를 통해 가져올 수 있다.
      
**값 타입**    
* `int`, `Integer`, `String` 등등의 자바 기본 타입 또는 객체            
* `값 타입`은 식별자가 없고 숫자나 문자로만 이루어져있어 **추적할 수 없다.**               
* 숫자 `100` -> `200` 으로 변경한다 가정하면, 완전히 다른 값으로 대체된 것이다.      
   
비유하자면, `엔티티 타입`은 `살아있는 생물`이고 `값 타입`은 단순한 수치 정보다.   
     
* **기본 값 타입**   
  * 자바 기본 타입
  * 래퍼 클래스
  * String
* **임베디드 타입(복합 값 타입)**  
* **컬렉션 값 타입**    
  
**기본 값 타입**은, 자바가 제공하는 `기본 데이터 타입`이다.      
**임베디드 타입**은, JPA에서 `사용자가 직접 정의한 값` 타입이다.     
**컬렉션 값 타입**은, `하나 이상의 값` 타입을 저장할 때 사용한다.     
   
# 기본 값 타입   

```java
```

자바에서 `int`, `double`과 같은 `프리미티브 타입은 절대 공유되지 않는다.`        
예를 들어 `a=b`와 같은 코드는 `b`를 직접적으로 사용하는 것이 아니라,        
`b`의 값을 **복사**해 `a`에 입력한다. 물론 `Integer`와 같은 래퍼 클래스나 `String`과 같은 특수한 클래스도 있다.      
이것들은 객체지만 자바 언어에서 기본 타입처럼 사용할 수 있게 지원하므로 기본값 타입으로 정의했다.       
     
**기본 값 타입 특징**      
* 생명 주기를 엔티티에 의존하고 있다.       
* 값 타입은 공유하면 안 된다. (사이드 이펙트가 일어나지 않아야한다.)     
    * 프리미티브 타입은, 공유가 아닌 복사로 이 같은 특징에 알맞다.         
     
       
# 임베디드 타입(복합값 타입)     
JPA에 맞추어 새로운 `값 타입`을 직접 정의한 타입을 `임베디드 타입`이라 말한다.         
    
**기본값 타입**
```java
@Entity
public class Member {
    
    @Id @GeneratedValue
    private Long id;
    private String name;
    
    // 근무 기간
    @Temporal(TemporalType.DATE) startDate;
    @Temporal(TemporalType.DATE) endDate;
    
    // 집 주소 표현
    private String city;
    private String street;
    private String zipcode;
    // ...
}
```
위 엔티티를 바라봤을 때 아래와 같은 특징을 도툴할 수 있다.   

* 회원 엔티티 : `이름`, `근무 시작일`, `근무 종료일`, `주소 도시`, `주소 번지`, `주소 우편 번호`    

하지만, 이는 단순히 필드를 풀어서 설명한 것일 뿐이다.    
이것 보다는 아래와 같이 설명하는 것이 더 좋을 것이다.   

* 회원 엔티티 : `이름`, `근무 기간`, `집 주소`   

회원이 상세한 데이터를 그대로 가지고 있는 것은 객체지향적이지 않으며 **응집력만 떨어뜨린다.**   
대신에 `근무 기간`, `주소` 같은 타입이 있다면 코드가 더 명확해질 것이다.       
보다 정확히 말하면, `DB`를 위해 필드를 풀어 해치지말고, 객체지향적인 코드를 작성해보자       

**값 타입 전용 회원 엔티티**
```java
@Entity
public class Member {
    
    @Id @GeneratedValue
    private Long id;
    private String name;
    
    @Embedded Period workPeriod;    // 근무 기간 
    @Embedded Address homeAddress;  // 집 주소  
    // ...
}
```
**Period**
```java
@Embeddable
public class Period {
    
    @Temporal(TemporalType.DATE) startDate;
    @Temporal(TemporalType.DATE) endDate;
    
    public boolean isWork(Date date) {
        // ...값 타입을 위한 메서드를 정의할 수 있다.   
    }
}
```

**Address**
```java
@Embeddable
public class Address {
    
    @Column(name="city)
    private String city;
    private String street;
    private String zipcode;
    // ..
}
```

위 분리된 클래스들을 통해 엔티티(객체)가 보다 의미있어지게 되었고
가독성과 재사용성은 물론, 각각의 클래스들은 응집력이 높아진 상태임을 확인할 수 있다.       
  
임베디드 타입을 사용하려면 다음 2가지 어노테이션이 필요하다.      
   
* @Embeddable : 값 타입을 정의하는 곳에 표시한다.     
* @Embedded : 값 타입을 사용하는 곳에 표시한다.     

그리고 **임베디드 타입 클래스는 `기본 생성자`가 필수다.** [이유](https://dundung.tistory.com/222)   
임베디드 타입을 포함한 모든 값 타입은 엔티티의 생명주기에 의존하므로       
엔티티와 임베디드 타입의 관계를 UML 로 표현하자면 `컴포지션 관계`가 된다.    
   
## 임베디드 타입과 테이블 매핑   
임베디드 타입을 데이터베이스 테이블에 매핑하는 방법을 알아보자   

## 임베디드 타입과 연관관계  

## @AttribuiteOverride : 속성 재정의   
임베디드 타입에 정의한 매핑정보를 재정의하려면 엔티티에 `@AttributeOverride`를 사용하면 된다.   
예를 들어 회원에게 주소가 하나 더 필요하면 어떻게 해야할까?   

**Member**
```java
@Entity
public class Member {
    
    @Id @GeneratedValue
    private Long id;
    private String name;
    
    @Embadded Address homeAddress;
    @Embadded Address companyAddress;
    
}
```


  

