# 객체지향 쿼리 언어  

`JPA`에서는 아래와 같은 방법으로 객체를 조회할 수 있다.     

* 식별자로 조회 : `EntityManager.find()` 
* 객체 그래프 탐색 : `조회된객체.getSomeThing()`   
       
하지만, 위 기능만으로 온전한 애플리케이션을 개발하기는 힘들다.        
예를 들어, `나이가 30 이상인 회원`, `키가 170 이상인 회원`과 같이        
`특정 조건`에 대한 `상세 정보`를 검색하고자 하면 이를 표현할 방법이 없기 때문이다.      
         
물론, 모든 값을 가져와서 애플리케이션단에서 처리를 할 수 는 있겠지만    
그렇다고 모든 회원 엔티티를 메모리에 올려두고 검색하는 것은 현실성이 없다.  
**결국, DB에 있는 데이터를 SQL을 이용하여 최대한 걸러서 조회해야한다.**   
     
ORM을 사용하면 DB 테이블이 아닌 엔티티 객체를 대상으로 개발을 한다.       
그렇기에 검색도 테이블이 아닌 엔티티 객체를 대상으로 하는 방법이 필요해졌고      
이러한 문제를 해결하기 위해 `JPQL`이 만들어졌다.      
       
**JPQL 특징**
* 테이블이 아닌 객체를 대상으로 검색하는 객체지향 쿼리다.    
* SQL을 추상화해서 특정 DB SQL에 의존하지 않는다.   
       
`SQL` 은 오롯이 `DB 테이블`을 대상으로 하는 `데이터 중심의 쿼리`이다.          
`JPQL` 은 오롯이 `엔티티 객체`를 대상으로 하는 `객체지향 쿼리`이다.          

`JPQL`을 한마디로 정의하면 `객체지향 SQL`이다.   
`SQL`과 문법이 매우 비슷하기에 몇 가지 차이점만 이해하면 쉽게 적응가능하다.     

`JPA`는 `JPQL` 말고도 다양한 검색 방법을 제공한다.  

**JPA 공식 검색 기능**   
* **JPQL**        
* **Criteria 쿼리 :** `JPQL`을 편하게 작성하도록 도와주는 `API`, 빌더 클래스 모음             
* **네이티브 SQL :** `JPA`에서 `JPQL` 대신 직접 `SQL`을 사용할 수 있다.          

**JPA 비공식 검색 기능**   
* **QueryDSL :** Criteria 쿼리처럼 JPQL을 편하게 작성라도록 도와주는 빌더 클래스 모음,   
    비표준 오픈소스 프레임워크이다.    
* **JDBC, MyBatis 같은 SQL 매퍼 프레이워크 :** 필요하면 JDBC를 직접 사용할 수 있다.    

## JPQL 소개  
* **JPQL은 엔티티 객체를 조회하는 객체지향 쿼리다.**    
  문법은 `SQL`과 비슷하고 `ANSI 표준 SQL`이 제공하는 기능을 유사하게 지원한다.        
* **`JPQL`은 SQL을 추상화해서 `특정 DB`에 의존하지 않는다.**   
  그렇기에 DB 방언(dialect)에 대한 설정만 바꿔주기만 하면 코드의 변경없이 활용가능하다.     
* **JPQL은 SQL보다 간결하다.**  
  `엔티티 직접 조회`, `묵시적 조인`, `다형성 지원`으로 `SQL`보다 코드가 간결하다.     

**Member 엔티티**
```java
@Entity(name = "Member")   
public class Member {
    
    @Column(name = "name")  
    private String username;
    // ...
}
```
   
**JPQL 사용**     
```java
String jqpl = "select m from Member as m where m.username = 'kim'";
List<Member> resultList = em.createQuery(jpql, Member.class).getResultList();
```     
위 코드는 `회원 이름이 kim`인 **엔티티를 조회한다.**         
   
* `JPQL` 에서 `Member`는 **엔티티 이름이다.(영속성 컨텍스트에 들어가는 엔티티의 이름, @Entity(name=""))**   
* `m.username` 은 테이블 컬럼명이 아니라 **엔티티 객체의 필드명이다.(컬럼명이 아닌 필드명이다.)**     
* `em.createQuery()`에는 `JPQL`문자열과 엔티티 클래스 타입을 넘겨주면 된다.    
* `.getResultList()`메서드를 실행하면 `JPA`는 `JPQL`을 `SQL`로 변환해서 DB를 조회하고 결과를 반환한다.   

## Criteria 소개  
`Creteria`는 `JPQL`을 생성하는 `빌더 클래스`이다.    
`Criteria`의 장점은 **`query.select(m).where(...)`처럼 프로그래밍 코드로 JPQL을 작성할 수 있다.**    
`빌더`를 사용하기에, 문자열을 직접 입력하면서 생기는 오타와 같은 문제를 방지할 수 있다.   
   
**Criteria 장점**    
* 컴파일 시점에 오류를 발견할 수 있다.      
* `IDE`를 사용하면 코드 자동완성을 지원한다.       
* 동적 쿼리를 작성하기 편하다.     
   
`Hibernate`를 포함한 몇몇 `ORM 프레임워크`들은 이미 오래 전부터 자신만의 `Criteria`를 지원했고    
`JPA`는 `JPA 2.0`부터 `Criteria`를 지원한다.    

**Criteria 쿼리**
```java
// Criteria 사용 준비  
Criteria criteria = em.getCreteriaBuilder();
CriteriaQuery<Member> query = criteria.createQuery(Memeber.class);

// 루트 클래스(조회를 시작할 클래스)   
Root<Member> m = query.from(Member.class);

// 쿼리 생성
CriteriaQuery<Member> cq = query
        .select(m)
        .where(criteria.equal(m.get("username"), "kim"));

// em 으로 CriteriaQuery 객체 조회 실행 
List<Member> resultList = em.createQuery(cq).getResultList();
```
위 코드를 보면, 문자가 아닌 코드로 작성한 것을 확인할 수 있다.   
다만 조금 아쉬운점은 `m.get("username")`에서 문자가 사용된다는 점이다.   
이마저도 문자가 아닌 코드로 작성하고 싶으면 `메타 모델`을 사용하면 된다.     
    
`메타 모델 API`에 대해서 알아보자.       
자바가 제공하는 `어노테이션 프로세서` 기능을 사용하면 어노테이션을 분석해서 클래스를 생성할 수 있다.    
(어노테이션 프로세서는 어노테이션을 분석해서 실제 동작을 만드는 작업이다.)      
이 기능을 사용해서 `Member 엔티티 클래스`로 부터    
`Member_`라는 `Criteria 전용 클래스`를 생성하는데 이를 `메타 모델`이라고 부른다.     

```java
m.get("username") => m.get(Member_.usernmae)
```
    
**Criteria가 가진 장점은 많지만 모든 장점을 상쇄할 정도로 복잡하고 장황하다.        
따라서, 사용하기 불편한 건 물로인고 Criteria로 작성한 코드도 한눈에 들어오지 않는 단점이 있다.**       

## QueryDSL 소개  
`QueryDSL`도 `Criteria` 처럼 **`JPQL 빌더` 역할을 한다.**  
`QueryDSL`의 장점은 코드 기반이면서 단순하고 사용하기 쉬우며 한눈에 이해하기 쉽다.  

**참고**   
```
QueryDSL은 JPA 표준은 아니고 오픈소스 프로젝트다.    
이것은 JPA뿐만 아니라, JDO, 몽고DB        
Java Collection, Lecene, Hibernate Search 도 거의 같은 문법으로 지원한다.         
```    
  
**QueryDSL로 작성한 코드**  
```java
JPAQuery query = new JPAQuery(em);
QMember member = QMember.member;

List<Member> members = query
        .from(member)
        .where(member.username.eq("kim"))
        .list(member);
```
`QueryDSL`도 `어노테이션 프로세서`를 사용해서 쿼리 전용 클래스를 만들어야 한다.      
`QMember`는 `Member 엔티티 클래스`를 기반으로 생성한 `QueryDSL 쿼리 전용 클래스`이다.   
자세한 설명은 차후에 `QueryDSL` 강의를 통해 설명하겠다.     
    
## Native SQL 소개     
`Native SQL`란, `JPA`에서 `SQL`을 직접 사용할 수 있도록 지원하는 기능이다.      

`JPQL`을 사용하더라도 가끔은 `특정 DB`에 의존하는 기능을 사용해야 할 때가 있다.     
`Oracle의 CONNECT BY` 나 `특정 DB에만 동작하는 SQL 힌트` 같은 것들 말이다.      
이런 기능들은 **전혀 표준화가 되어 있지 않으므로 JPQL에서는 사용을 할 수 없다.**     
즉, `SQL`은 지원하지만 `JPQL`이 지원하지 않는 기능이라는 뜻이다.   
바로 이럴때 사용되는 것이 `Native SQL`이다.  

`Native SQL`의 단점은 아무래도 `SQL문`을 작성하는 것이므로   
개발자가 `SQL`을 직접 작성했을 때 발생하는 문제점을 고스란히 가지게 된다.   

## JDBC 사용, MyBatis 같은 SQL 매퍼 프레임워크 사용 
이런 일은 드물지만, `JDBC 커넥션`에 직접 접근하고 싶으면      
`JPA`는 `JDBC 커넥션을 획득하는 API`를 제공하지 않으므로      
`JPA` 구현체가 제공하는 방법을 사용해야 한다.         
    
**하이버네이트 JDBC 획득**
```java
Session session = entityManager,unwrap(Session.class);
session.doWork(new Work() {
    
    @Override
    public void execute(Connection connection) throws SQLException {
        // work
    }
}
```

`JPA`의 [Hibernate Session](https://javacan.tistory.com/entry/101)을 구하고 `doWork()`메서드를 호출하도록 했다.   
**JDBC나 MyBatis를 JPA와 함께 사용하면 영속성 컨텍스트를 적절한 시점에 강제로 플러시해야한다.**   
왜냐하면 `JPA`를 우회해서 접근하기 때문이다. (JPA가 인식못하므로)    

가장 주의해야할 점은 `영속성 컨텍스트`와 `DB`를 불일치 상태로 만들어 `데이터 무결성`을 훼손 시키는 것이다.         
이런 이슈를 해결하는 방법은 `JPA`를 우회해서 `SQL`을 실핼행하기 직전에       
`영속성 컨텍스트`를 `수동으로 플러시`해서 `DB 영속성 컨텍스트`를 동기화하면 된다.    

만약, `스프링`을 사용한다면 `AOP`를 적절히 이용할 수 있기에      
`DB 접근 메서드`를 호출할 때마다 `영속성 컨텍스트`를 `플러시`하면 된다.   

# JPQL   

**JPQL 특징**   
* `JPQL`은 `객체지향 쿼리 언어`다.   
  따라서 테이블을 대상으로 쿼리하는 것이 아니라 엔티티 객체를 대상으로 쿼리한다.   
* `JPQL`은 `SQL`을 추상화해서 `특정 DB`의 `SQL`에 의존하지 않는다.   
* `JPQL`은 결국 `SQL로 변환`된다.     

## 기본 문법과 API      
`JPQL`도 `SQL`과 비슷하게 `SELECT`, `UPDATE`, `DELETE`문을 사용할 수 있다.   
참고로, `INSERT`문은 `EntityManager.persist()`메서드를 사용하면 된다.   

**JPQL 문법**
```java
select_문 :: = 
    select_절
    from_절
    [where_절]
    [groupby_절]
    [having_절]
    [orderby_절]

update_문 :: = update_절 [where_절]
delete_문 :: = delete_절 [where_절]
```

### SELECT 문 

```java
SELECT m FROM Member AS m where m.username = 'Hello'
```
   
* 대소문자 구분
    * 엔티티 속성은 대소문자를 구분한다. : `Member`, `username` 같은 요소들
    * JPQL 키워드는 대소문자를 구분하지 않는다 : `SELECT`, `FROM`, `AS`
* 엔티티 이름 
    * JPQL 에서 사용하는 Member 는 `엔티티 명`이다.  
    * 즉, `@Entity(name = "XXX")`이다.    
* 별칭은 필수 
    * `JPQL`은 별칭을 필수로 사용해야 한다.  
    * `Member As m` 을 보면, `Member`에 `m`이라는 별칭이 주었다.  
    * `AS`는 생략할 수 있다.   


**참고**   
`Hibernate` 는 `JPQL 표준`도 지원하지만, 더 많은 기능을 가진 `HQL`이라는 것도 지원한다.     
`JPA 구현체`로 하이버네이트를 사용한다면 `HQL`도 사용할 수 있다.   
`HQL`은 `SELECT uesrname FROM Member m`의 `username`처럼 별칭 없이 사용할 수 있다.   

#### TypeQuery, Query   
JPQL을 실행하려면 쿼리 객체를 만들어야 하는데 아래 2가지가 있다.   

* **TypeQuery :** 반환할 타입이 명확할 경우 사용한다.   
* **Query :** 반환할 타입이 명확하지 않을 경우 사용한다.   

**TypeQuery 사용**
```java
TypeQuery<Member> query = 
    em.createQuery("SELECT m FROM Member m", Member.class);
    
List<Member> resultList = query.getResultList();
for (Member member : resultList) {
    System.out.println("member = " + member);
}
```
**Query 사용**
```java
Query query = 
    em.createQuery("SELECT m.username, m.age from Member m");

List reslutList = query.getResultList(); // Object로 반환하는가 보다.  
for (Object o : resultList) {
    Object[] result = (Object[]) o;
    System.out.println("username = " + result[0]);
    System.out.println("age = " + result[1]);
}
```
`em.createQuery()`은,      
반환 타입을 지정하면 `TypeQuery`를 반환하고     
반환 타입을 지정하지 않으면 `Query`를 반환한다.    

`Query` 객체는 조회 대상의 컬럼 수가 `2 이상`이라면 `Object[]` 를 반환하고 하나면, `Object`를 반환한다.  
두 코드를 비교하면 알 수 있듯이 `TypeQuery`가 사용하기 더 편리하다.   

#### 결과 조회
결과를 조회할 때는 아래와 같은 메서드를 이용한다. 

* `query.getResultList():`   
  결과를 예제로 반환한다.    
  만약 결과가 없으면 빈 컬렉션을 반환한다.   
* `query.getSingleResult():`  
  결과가 정확히 하나일 때 사용한다.   
  결과가 없으면 `javax.persistence.NoResultException`이 발생한다.  
  결과가 1개보다 많으면 `javax.persistence.NonUniqueResultException` 예외가 발생한다.   

### 파라미터 바인딩  
`JDBC`는 위치 기준 파라미터 바인딩만 지원하지만,       
`JPQL`은 **이름 기준 파라미터 바인딩도 지원한다.**    
  
**이름 기준 파라미터**        
이름 기준 파라미터는 앞에 `:`를 사용한다.      
```java
String usernameParam = "User1";


List<Member> resultList =
        em.createQuery("SELECT m FROM Member m Where m.username = :username", Member.class)   
        .setParameter("username", usernameParam)
        .getResultList();
```
예제에서는 위와 같이 안나왔지만, 체이닝 방식을 사용하는 것은 적극적으로 찬성한다.  
그렇기에 필자의 생각에 맞춰서 체이닝 방식으로 변형을 해보았다.   
       
**위치 기준 파라미터**     
`JPQL`은 이름은 물론, `순서`에 맞게끔 데이터를 바인딩 할 수 있다.             
      
```java
List<Member> members = 
        em.createQuery("SELECT m FROM Member m Where m.username = ?1", Member.class)   
        .setParameter(1, usernameParam)
        .getResultList();
```

`위치 기준 파라미터 바인딩` 같은 경우 `위치`는 얼마든지 변형될 가능성이 있으므로,   
`이름 기준 파라미터 바인딩` 방식을 사용하는것을 권장한다.   

**참고**     
`stmt` 또는, 쿼리를 문자열 덧셈으로 직접 만드는 방법은   
악의적인 사용자에 의해 `SQL 인젝션` 공격을 당할 수 있으며 `성능 이슈`도 있다.    
이에 비해, `파라미터 바인딩 방식`은 파라미터의 값이 달라도 같은 쿼리로 인식해서    
`JPA`는 `JPQL`을 `SQL`로 파싱한 결과를 재사용할 수 있다.    
그리고 데이터베이스도 내부에서 실행한 `SQL`을 파싱해서 사용하는데 같은 쿼리는 파싱한 결과를 재사용할 수 있다.     
결과적으로 애플리케이션과 데이터베이스 모두 해당 쿼리의 파싱 결과를 재사용할 수 있어서 전체 성능이 향상된다.    
따라서 **파라미터 바인딩 방식(위치/이름)은 선택이 아닌 필수다.**        

### 프로젝션  
프로젝션이란, `SELECT` 절에 조회할 대상(컬럼)을 지정하는 것을 의미한다.    
프로젝션 대상에는 `엔티티`, `임베디드 타입`, `스칼라 타입(기본 타입)`이 있다.     

**엔티티 프로젝션**
```sql
SELECT m FROM Member m;      // Memebr 엔티티 조회
SELECT m.team FROM Member m; // Team 엔티티 조회 
```
위 코드를 쉽게 설명하면, 원하는 객체를 바로 조회한 것이다.      
이렇게 `조회한 엔티티는 영속성 컨텍스트에서 관리`한다.    
       
**임베디드 타입 프로젝션**
`JPQL`에서 임베디드 타입은 엔티티와 거의 비슷하게 사용된다.     
임베디드 타입은 조회의 시작점이 될 수 없다는 제약이 있다.  
그렇기에 `String query = "SLECET a FROM Address a";`와 같이 사용할 수는 없다.    
    
아래와 같은 코드를 통해, `임베디드 타입 객체`를 구할 수 있다. (엔티티 아니다)    

```java    
String query = "SELECT o.address FROM Order o";     
List<Address> addresses = em.createQuery(query, Address.class)     
        .getResultList();
```

위 코드를 동작시키면 아래와 같은 `SQL`이 실행된다.    
   
```sql
select 
    order.city,
    order.street,
    order.zipcode
from
    Orders order
```
앞서 언급했듯이, 임베디드 타입은 엔티티 타입이 아닌 **값 타입**이다.      
그렇기에 이렇게 직접 조회한 **임베디드 타입은 영속성 컨텍스트에서 관리되지 않는다.**      

**스칼라 타입 프로젝션**   
`숫자`, `문자`, `날짜`와 같은 기본 데이터 타입들을 `스칼라 타입`이라 한다.       






   







  








  





  









 


  
   



















