2차 캐시
===========

# 1차 캐시와 2차 캐시   
네트워크를 통해 데이터베이스에 접근하는 시간 비용은                 
애플리케이션 서버에서 내부 메모리에 접근하는 시간 비용보다 수만에서 수십만배 이상 비싸다.          
따라서 **조회한 데이터를 메모리에 캐시해서 데이터베이스 접근 횟수를 줄이면 애플리케이션 성능을 획기적으로 개선할 수 있다.**       

영속성 컨텍스트 내부에는 엔티티를 보관하는 저장소가 있는데 이것을 1차 캐시라 한다.          
1차 캐시의 이점은 많지만, 트랜잭션을 시작하고 종료할 때까지만 1차 캐시가 유효하여 범위가 작다.(OSIV도 동일)      
따라서 애플리케이션 전체로 보면 데이터베이스 접근 횟수를 획기적으로 줄이지는 못한다.     
  
대부분의 JPA 구현체들은 **애플리케이션 범위의 캐시를 지원하는데 이것을 공유 캐시 또는 2차 캐시라고 한다.**           
이런 2차 캐시를 이용하면 애플리케이션 조회 성능을 향상 시킬 수 있다.(메모리에 존재하는 DB 데이터)    
   
[#](#)   
  
## 1차 캐시   
1차 캐시는 영속성 컨텍스트 내부에 있다.          
엔티티 매니저로 조회하거나 변경하는 모든 엔티티는 1차 캐시에 저장된다.        
트랜잭션을 커밋하거나 플러시를 호출하면 1차 캐시에 있는 엔티티의 변경 내역을 데이터에비스에 동기화한다.   

트랜잭션을 시작할 때 영속성 컨텍스트를 생성하고, 트랜잭션을 종료할 때 영속성 컨텍스트도 종료한다.      
OSIV를 사용하면 요청 시작부터 끝까지 같은 영속성 컨텍스트를 유지한다.     
1차 캐시는 끄고 켤 수 있는 옵션이 아니다.(영속성 컨텍스트 자체가 사실상 1차 캐시다)     

[#](#)
  
1. 최초 조회할 때는 1차 캐시에 엔티티가 없으므로  
2. 데이터베이스에서 엔티티를 조회해서   
3. 1차 캐시에 보관하고   
4. 1차 캐시에 보관한 결과를 반환한다.   
5. 이후 같은 엔티티를 조회하면 1차 캐시에 같은 엔티티가 있으므로      
   데이터베이스를 조회하지 않고 1차 캐시의 엔티티를 그대로 반환한다.   

1차 캐시의 특징은 다음과 같다.    
* 1차 캐시는 같은 엔티티가 있으면 해당 엔티티를 그대로 반환한다.(1차 캐시는 객체 동일성을 보장한다.)      
* 1차 캐시는 기본적으로 영속성 컨텍스트 범위의 캐시다.   
  (컨테이너 환경에서는 트랜잭션 범위의 캐시, OSIV를 적용하면 요청 범위의 캐시다.)   

## 2차 캐시   






