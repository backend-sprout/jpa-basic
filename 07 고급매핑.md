# 상속 관계 매핑    
`RDB`에는 객체지향과 다르게 **`상속`이라는 개념이 없다.**      
대신에 이와 비슷한 `슈퍼 타입` 과 `서브 타입`관계라는 모델링 기법을 이용한다.      
`ORM`에서의 `상속 관계 매핑`은 DB의 `슈퍼/서브타입` 관계를 맵핑하는 것이다.    
      
`슈퍼 타입 서브 타입` 논리 모델을     
실제 물리 모델인 테이블로 구현할 때는 `3가지` 방법이 있다.     

* **각각의 테이블로 변환 :**   
  각각을 모두 테이블로 만들고 조회할 때 `JOIN`을 사용한다.   
  `JPA` 에서는 이를 **조인 전략**이라고 말한다.  
* **통합 테이블로 변환 :**    
  테이블을 하나만 사용해서 `통합`한다.     
  `JPA` 에서는 **단일 테이블 전략**이라고 한다.      
* **서브 타입 테이블로 변환 :**     
  `서브 타입`마다 하나의 테이블을 만든다.      
  `JPA` 에서는 **구현 클래스마다의 테이블 전략**이라고 한다.     
        
## 조인 전략    
엔티티 각각을 모두 테이블로 만들고       
자식 테이블이 부모 테이블의 기본 키를 받아서      
**`기본 키` + `외래 키`로 사용하는 전략이다.**        
따라서 조회할 때, `JOIN`을 많이 사용한다.     
    
단, 해당 전략을 사용할 때 주의할 점이 있는데   
객체는 `타입`으로 구분할 수 있지만,   
테이블은 `타입의 개념이 없다.`     
따라서 **타입을 구분하는 `구분 컬럼`을 추가해야 한다.**      
   
**Item**
```java
@Entity
@Inheritance(strategy = InheritanceType.JOINED)
@DiscriminatorColumn(name = "DTYPE")
public abstract class Item {

    @Id
    @GeneratedValue // Identity면 에러
    private Long id;

    private String name;

    private int price;

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getPrice() {
        return price;
    }

    public void setPrice(int price) {
        this.price = price;
    }
}
```   
* **@Inheritance(strategy = InheritanceType.JOINED) :**   
  상속 매핑은 부모 클래스에 `@Inheritance`어노테이션을 붙여야 한다.      
  그리고 여러 매핑 전략이 있는데 `InheritanceType.JOINED`은 **조인 전략이다**    
* **@DiscriminatorColumn(name = "DTYPE") :**   
  부모 클래스에 `구분 컬럼`을 지정한다.         
  기본값은 `DTYPE`이지만, `name=이름`을 이용해서 컬럼 이름을 바꿀 수 없다.       
  이외의 나머지 속성들의 종류는 `@Column`의 속성들과 동일하다.      

**Movie**
```java
@Entity
@DiscriminatorValue("M")
public class Movie extends Item {

    private String director;
    private String actor;

    public String getDirector() {
        return director;
    }

    public void setDirector(String director) {
        this.director = director;
    }

    public String getActor() {
        return actor;
    }

    public void setActor(String actor) {
        this.actor = actor;
    }
}
```

**Album**
```java
@Entity
@DiscriminatorValue("A")
public class Album extends Item {

    private String artist;

    public String getArtist() {
        return artist;
    }

    public void setArtist(String artist) {
        this.artist = artist;
    }
}
```

**Book**
```java
@Entity
@DiscriminatorValue("B")
public class Book extends Item {

    private String author;
    private String isbn;

    public String getAuthor() {
        return author;
    }

    public void setAuthor(String author) {
        this.author = author;
    }

    public String getIsbn() {
        return isbn;
    }

    public void setIsbn(String isbn) {
        this.isbn = isbn;
    }
}
```  
* **@DiscriminatorValue("이름") :**     
  엔티티를 저장할 때 `구분 컬럼`에 입력할 값을 지정한다.      
  만약 영화 엔티티를 저장하면 구분 컬럼인 `DTYPE`에 `"이름"`이 저장된다.     
          
기본값으로 자식 테이블은 부모 테이블의 ID 컬럼명을 그대로 사용한다.       
그러나 만약 **자식 테이블의 기본 키 컬럼명을 변경하고 싶으면**       
**`@PrimaryKeyJoinColumn`을 사용하면 된다.**   

```java
@Entity
@DiscriminatorValue("B")   
@PrimaryKeyJoinColumn(name = "BOOK_ID") // id 값 변경  
public class Book extends Item {
    
    private String author;
    private String isbn;
}
```
Book 테이블의 `ITEM_ID` 기본 키 컬럼명을 `BOOK_ID`로 바꾸었다.  

**조인 전략 정리**    
* **장점 :**
  * 테이블이 정규화 된다.  
  * 외래키 참조 무결성 제약조건을 활용할 수 있다.  
  * 저장공간을 효율적으로 사용한다.  
* **단점 :**   
  * 조회할 때 조인이 많이 사용되므로 성능이 저하될 수 있다.  
  * 조회 쿼리가 복잡하다.  
  * 데이터를 등록할 때 `INSERT SQL` 을 `두 번` 실행한다. (Item/자식 한번 씩)            
* **특징 :**   
  * JPA 표준 명세는 `구분 컬럼`을 사용하도록 권장하지만   
    하이버네이트를 포함한 몇몇 구현체는 `구분 컬럼` 없이도 잘 동작한다.   
    그리고 사실, `조인 전략`이 이에 해당된다.   
    
## 단일 테이블 전략    


   
