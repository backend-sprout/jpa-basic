# 연관 관계 매핑 기초  
엔티티들은 대부분 다른 엔티티와 연관관계가 있다.    
그런데 **객체는 참조**를 사용해서 관계를 맺고 **테이블은 외래키**를 사용해서 관계를 맺는다.     
`ORM`에서 가장 어려운 부분이 **`객체 연관관계`와 `테이블 연관관계`를 매핑하는 것이다.**         

* **방향(Direction) :**   
    * 단반향/양방향이 있다.
    * **단방향 :** 둘 중 하나만 참조 
    * **양방향 :** 양쪽 모두 서로를 참조  
    * 방향은 객체 관계에서만 존재하고 **테이블 관계는 항상 양방향**이다.  
* **다중성(Multiplicity) :**  
    * `N:1`, `1:N`, `1:1`, `N:M` 다중성이 있다.   
* **연관관계의 주인 :**  
    * 객체를 양방향 관계로 만들면 연관관계의 주인을 정해야 한다.   

# 단방향 연관관계 (1:N)   
  
**가정**
* 회원과 팀이 있다.  
* 회원은 하나의 팀에만 소속될 수 있다.  
* 회원과 팀은 `다대일(1:N)` 관계이다.  
  
[PPT]()

**객체 연관관계**  
* `Member 객체`는 `Member.team`필드로 `Team 객체`와 연관관계를 맺는다.  
* **단방향 관계이다.**   
    * 회원은 -> 팀을 알 수 있다. 
    * 팀 -> 회원을 알 수 없다.  
  
**테이블 연관관계**   
* `Member 테이블`은 `TEAM_ID` 외래 키로 `Team 테이블`과 연관관계를 맺는다.  
* `Member 테이블`과 `Team 테이블`은 **양방향 관계이다.**  
    * `Member 테이블`은 `TEAM_ID`를 통해 `Team`을 조회할 수 있다. (회원과 팀)  
    * `Team 테이블`은 `PK`인, `TEAM_ID`를 통해 `Member`를 조회할 수 있다.(팀과 회원)  
    * 즉, `MEMBER JOIN TEAM(회원과 팀)`은 물론, `TEAM JOIN MEMBER(팀과 회원)`도 가능하다.     
      
**객체 연관관계와 테이블 연관관계의 가장 큰 차이**   
**참조를 통한 연관관계는 언제나 단방향이다.**  
객체간의 연관관계를 **양방향으로 만들고 싶으면**     
**반대쪽에도 필드를 추가해서 참조를 보관해야한다.**   
즉, 연관관계를 하나 더 만들어야 하고 이를 양방향 연관관계라 말한다.  
하지만, 보다 더 정확히 말하면,   
**양뱡향 관계가 아니라 서로 다른 단방향 관계 2개이다.**     
    
## 순수한 객체 연관관계   

[PPT]()

**회원과 팀 클래스**
```java
```
**동작 코드**
```java
```

객체는 참조를 사용해서 연관관계를 탐색할 수 있는데    
이것을 **객체 그래프 탐색**이라고 한다.   
참고로 이러한 객체 그래프 탐색을 진행할 때, 지연로딩이 효과적으로 사용된다.    
    
**테이블 연관관계** 
테이블 연관관계는 `FK`와 `JOIN`을 이용하여 연관관계를 탐색한다.      

## 객체 관계 매핑 

[PPT]() 

```java

```
```java
```

* **객체 연관관계 :** 회원 객체의 `Member.team`필드 사용 
* **테이블 연관관계 :** 회원 테이블의 `MEMBER.TEAM_ID` 외래 키 컬럼을 사용  

`Member.team`과 `MEMBER.TEAM_ID`를 매핑하는 것이 연관관계 매핑이다.   
이를 보다 명확히 알기 위해 코드를 확인해보자   
  
```java
@ManyToOne  
@JoinColumn(name="TEAM_ID")     
private team team;  
```  
* **@ManyToOne :** 
    `다대일(N:1)`관계에 대한 매핑 정보,
    연관관계를 매핑할 때 다중성을 나타내는 어노테이션은 필수로 사용해야한다.   
* **@JoinColumn(name="TEAM_ID") :**   
    외래 키를 매핑할 때 사용하는 어노테이션이다.   
    `name` 속성에는 매핑할 외래 키 이름을 지정한다.(FK 이름 정하는 것이다.)      
    해당 어노테이션은 생략 가능하고 이럴 경우 기본값이 설정된다.  

### @ManyToOne
`@ManyToOne` 어노테이션은 `다대일(N:1)` 관계에서 사용한다.   

|속성|기능|기본값|  
|----|---|------|
|optional|`false`로 설정하면 연관된 엔티티가 항상 있어야 한다.|true|
|fetch|글로벌 페치 전략을 설정한다.(로딩시점)|@ManyToOne=FetchType.EAGER<br>@OneToMany=FetchType.LAZY|   
|cascade|영속성 전이 기능을 사용한다.||
|targetEntity|연관된 엔티티의 타입 정보를 설정한다.<br>이 기능은 거의 사용하지 않는다.<br>컬렉션을 사용해도 제네릭으로 타입 정보를 알 수 있다.|   
 
이 중에서 `targetEntity`과 제네릭의 연관성에 대해 간략히 표현해보겠다.       
```java
@OneToMany
private List<Member> members; // 제네릭으로 타입 정보를 알 수 있다.  

@OneToMany(targetEntity=Member.class)
private List members; // 제네릭이 없으면 타입 정보를 알 수 없다.   
```  
`targetEntity`는 제네릭`<>`이 없을 경우, 타입 정보를 알 수 없다.      
**그렇다면 제네릭 등장 이전의 코드들은 어떻게 동작을 할까?🤔**    
정확히 말하면, 제네릭 등장 이전에는 명확히 해당 클래스를 명시해줘야 했다.       
그러나 제네릭이 등장하면서 이를 생략 가능해졌기에 잘 사용하지 않는 것이다.      

```java
@ManyToMany(targetEntity=com.example.NoteBook.class)
@JoinTable(name="person_has_notebooks", joinColumns={@JoinColumn(name="person_id")}, inverseJoinColumns={@JoinColumn(name="notebook_id")})
private List notebooks;

@ManyToMany(mappedBy="notebooks", targetEntity=com.example.Person.class)
private List person;
```
[오라클 공식 레퍼런스](https://docs.oracle.com/javaee/6/api/javax/persistence/ManyToMany.html)


### @JoinColumn  



# 참고 
https://www.inflearn.com/questions/113969
