# 10 객체지향 쿼리 언어2   

## 페치 조인 
`페치 조인`은 SQL에서 이야기하는 조인의 종류는 아니다.   
**`페치 조인`은 JPQL의 성능 최적화를 위해 제공하는 기능이다.**    
   
페치 조인은, **연관된 엔티티나 컬렉션을 한번에 같이 조회하는 기능**으로      
**`join fetch` 명령어로 사용할 수 있다.**   

**N+1**
```
select member from Member m (order 연관관계(Member 1: N Order)를 가지고 있다.)  
```
`em.find()` 와 달리 `JPQL`은 해당 언어를 SQL로만 바꾸는 역할을 한다.   
즉, `em.find()`는 즉시로딩이라 하더라도 `JOIN`을 진행하지만,  
`JPQL`은 `SELECT`구문으로 진행이 된다.  
이때, 연관관계가 `EAGER`타입이라면 값을 가져옴과 동시에 초기화가 되어 있어야한다.  
그러므로 `select`를 이용하여 해당 FK(아이디) 값을 가진 `Order`를 가지고 온다.    

즉, Member 1개 가져올때 한개의 Order를 다시 SELECT로 검색해서 찾아오는 것이다.  
그렇기에 처음 전체 Member 를 가져오는 구문, 
각 Member 별 Order를 가져오는 N이 더해져서 N+1이 된다.   

   
   
**엔티티 페치 조인**  
```
select m
from Member m join fetch m.team
```
위 코드는 페치 조인을 사용해서 회원 엔티티를 조회하면서 연관된 엔티티도 함께 조회하는 `JPQL`이다.
단순히 `join` 옆에 `fetch`를 불였을 뿐이지만 **회원 엔티티와 팀 엔티티를 함께 조회한다.**   
참고로, `m.team`과 같이 `alias`를 사용할 수 없다.   


`엔티티 페치 조인`에서 `JPQL`에서 `select m`으로 회원 엔티티만 선택했는데   
실행된 `SQL`을 보면 `SELECT m.*, t.*`로 회원과 연관된 팀도 함께 조회된 것을 확인할 수 있다.    
그리고 회원과 팀 객체가 객체 그래프를 유지하면서 조회된 것 을 확인할 수 있다.   

```java
String jpql = "select m from Member m join fetch m.team"

List<Member> members = em.createQuery(jpql, Member.class)
    .getResultList();

for(Member member : members) {
    
    System.out.println("username = " + member.getUsername() + ", " + 
        "teamname = " + member.getTeam().name());
}
```    
   
